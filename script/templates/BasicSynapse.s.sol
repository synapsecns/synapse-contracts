// SPDX-License-Identifier: MIT
pragma solidity >=0.6.12;
pragma experimental ABIEncoderV2;

import {BasicUtils, StringUtils} from "./BasicUtils.sol";
import {IImmutableCreate2Factory} from "../interfaces/IImmutableCreate2Factory.sol";
import {IOwnable} from "../interfaces/IOwnable.sol";

// solhint-disable no-console
import {console2, VmSafe} from "forge-std/Script.sol";

contract BasicSynapseScript is BasicUtils {
    using StringUtils for string;
    using StringUtils for uint256;

    // Order of the struct members must match the alphabetical order of the JSON keys
    struct SaltEntry {
        bytes32 initCodeHash;
        address predictedAddress;
        bytes32 salt;
    }

    string internal constant TAB = "    ";
    /// @notice Deployed on lots of chains, could be deployed on more chains in a permissionless way
    address public constant IMMUTABLE_CREATE2_FACTORY = 0x0000000000FFe8B47B3e2130213B802212439497;
    /// @notice Deployed on lots of chains, could be deployed on more chains using EOA
    string public constant MINIMAL_CREATE2_FACTORY = "Create2Factory";

    /// @notice Name of the active chain, should match the name of the directory in deployments
    string public activeChain;
    /// @notice Map from chain name to chainId
    mapping(string => uint256) public chainIds;
    /// @notice Map from chainId to chain name
    mapping(uint256 => string) public chainNames;

    /// @notice Current indent level for all log messages
    uint256 private currentIndentLevel;
    /// @notice Salt to be used for the next create2 deployment
    bytes32 private nextDeploymentSalt;

    /// @notice Prepares the script for execution.
    function setUp() internal virtual {
        loadChainIds();
        loadActiveChain();
    }

    /// @notice Checks that the broadcaster is the owner of the contract.
    /// Note: vm.startBroadcast() should be called before this function.
    function checkOwner(address ownable) internal view returns (bool isOwner) {
        address owner = IOwnable(ownable).owner();
        isOwner = owner == msg.sender;
        if (!isOwner) {
            console2.log("Sender is not the owner");
            console2.log("   Owner: %s", owner);
            console2.log("  Sender: %s", msg.sender);
        }
    }

    // ══════════════════════════════════════════════════ LOGGING ══════════════════════════════════════════════════════

    /// @notice Prints the log message with the current indent level.
    function printLog(string memory logString) internal virtual override {
        console2.log(addIndent(logString));
    }

    /// @notice Prints the log message and an address with the current indent level.
    /// Note: logString should contain a %s placeholder for the address.
    function printLog(string memory logString, address addr) internal virtual {
        console2.log(addIndent(logString), addr);
    }

    /// @notice Prints the log message and two addresses with the current indent level.
    /// Note: logString should contain a %s placeholder for every address.
    function printLog(
        string memory logString,
        address a,
        address b
    ) internal virtual {
        console2.log(addIndent(logString), a, b);
    }

    /// @notice Adds the current indent level to the log message.
    function addIndent(string memory logString) internal view returns (string memory) {
        return currentIndent().concat(logString);
    }

    /// @notice Returns the current indent string.
    function currentIndent() internal view returns (string memory) {
        return TAB.duplicate(currentIndentLevel);
    }

    /// @notice Increases the indent level for all log messages.
    function increaseIndent() internal {
        ++currentIndentLevel;
    }

    /// @notice Decreases the indent level for all log messages.
    function decreaseIndent() internal {
        require(currentIndentLevel > 0, "Indent level cannot be negative");
        --currentIndentLevel;
    }

    // ═══════════════════════════════════════════════ DEPLOY UTILS ════════════════════════════════════════════════════

    /// @notice Creates a contract with the given name and constructor args.
    /// Bytecode generated by forge is used for the deployment.
    /// Note: could be used as callback for `deployAndSave` and `deployAndSaveAs`
    /// for contracts with a different compiler version.
    function deploy(string memory contractName, bytes memory constructorArgs) internal returns (address deployedAt) {
        // Init code is the contract bytecode with constructor args appended
        bytes memory initCode = abi.encodePacked(getContractBytecode(contractName), constructorArgs);
        // Use assembly to deploy the contract
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Add 0x20 to skip the length field of initCode
            deployedAt := create(0, add(initCode, 0x20), mload(initCode))
        }
        require(deployedAt != address(0), StringUtils.concat("Deployment failed: ", contractName));
    }

    /// @notice Creates a contract with the given name and constructor args.
    /// Bytecode generated by forge is used for the deployment.
    /// Deployment is done in a deterministic way, using create2 and salt saved in `nextDeploymentSalt`.
    /// Note: could be used as callback for `deployAndSave` and `deployAndSaveAs`.
    function deployCreate2(string memory contractName, bytes memory constructorArgs)
        internal
        returns (address deployedAt)
    {
        // Init code is the contract bytecode with constructor args appended
        bytes memory initCode = abi.encodePacked(getContractBytecode(contractName), constructorArgs);
        // If no salt was provided, try reading it from the pre-saved list
        if (nextDeploymentSalt == 0) {
            nextDeploymentSalt = loadDeploymentSalt(initCode, contractName);
        }
        deployedAt = factoryDeployCreate2(initCode, nextDeploymentSalt);
        // Erase the salt after the deployment
        nextDeploymentSalt = 0;
    }

    /// @notice Creates a contract with the given init code.
    /// Deployment is done in a deterministic way, using create2 and the given salt.
    /// Note: does not save the deployment JSON.
    function factoryDeployCreate2(bytes memory initCode, bytes32 salt) internal returns (address deployedAt) {
        // Get address of the factory on the active chain
        address factory = getDeploymentAddress(MINIMAL_CREATE2_FACTORY);
        assertContractCodeExists(MINIMAL_CREATE2_FACTORY, factory);
        address predicted = predictAddress(factory, initCode, salt);
        require(getCodeSize(predicted) == 0, "Contract already deployed");
        // Payload is salt + initCode
        bytes memory payload = abi.encodePacked(salt, initCode);
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returnData) = factory.call(payload);
        require(success, "CREATE2 deployment failed");
        // returnData is 20 bytes of address rather than ABI-encoded address
        require(returnData.length == 20, "Invalid return data");
        returnData = abi.encodePacked(bytes12(0), returnData);
        deployedAt = abi.decode(returnData, (address));
        require(deployedAt == predicted, "Invalid deployment address");
    }

    /// @notice Predicts the address of a contract that would be deployed with the given init code and salt.
    function predictAddress(bytes memory initCode, bytes32 salt) internal returns (address deployedAt) {
        address factory = getDeploymentAddress(MINIMAL_CREATE2_FACTORY);
        return predictAddress(factory, initCode, salt);
    }

    /// @notice Predicts the address of a contract that would be deployed with the given factory, init code and salt.
    function predictAddress(
        address factory,
        bytes memory initCode,
        bytes32 salt
    ) internal pure returns (address deployedAt) {
        deployedAt = address(
            uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), factory, salt, keccak256(initCode)))))
        );
    }

    /// @notice Sets the salt to be used for the next create2 deployment.
    function setDeploymentSalt(bytes32 salt) internal {
        nextDeploymentSalt = salt;
    }

    /// @notice Loads pre-saved deployment salt for a contract, if there is any.
    /// Note: returns 0 if there is no pre-saved salt.
    function loadDeploymentSalt(bytes memory initCode, string memory contractName)
        internal
        view
        returns (bytes32 salt)
    {
        bytes32 initCodeHash = keccak256(initCode);
        string memory allSalts = getGlobalConfig(MINIMAL_CREATE2_FACTORY, "salts");
        // Try to read the salt from the JSON
        try vm.parseJson(allSalts, StringUtils.concat(".", contractName)) returns (bytes memory encoded) {
            SaltEntry memory entry = abi.decode(encoded, (SaltEntry));
            require(entry.initCodeHash == initCodeHash, "Invalid init code hash");
            return entry.salt;
        } catch {
            // No key is present in the JSON, return 0
            return 0;
        }
    }

    /// @notice Deploys a contract and saves the deployment JSON, if the contract hasn't been deployed yet.
    /// See `deployAndSaveAs` below for more details.
    function deployAndSave(
        string memory contractName,
        bytes memory constructorArgs,
        function(string memory, bytes memory) internal returns (address) deployCode
    ) internal returns (address deployedAt) {
        // Use contractName as contractAlias by default
        return deployAndSaveAs(contractName, contractName, constructorArgs, deployCode);
    }

    /// @notice Deploys a contract and saves the deployment JSON, if the contract hasn't been deployed yet.
    /// Needs to be passed a generic function that deploys the contract, that follows this signature:
    /// deployCode(string memory contractName, bytes memory constructorArgs) internal returns (address deployedAt);
    /// - Example: deploy() and deployCreate2() could be used here, as they follow the signature. Or anything
    /// else that could deploy raw bytecode of any contract, most likely using assembly/factory approach.
    /// - Note: contract should be configured outside of `deployCode`.
    function deployAndSaveAs(
        string memory contractName,
        string memory contractAlias,
        bytes memory constructorArgs,
        function(string memory, bytes memory) internal returns (address) deployCode
    ) internal returns (address deployedAt) {
        printLog(
            contractName.equals(contractAlias)
                ? StringUtils.concat("Deploying: ", contractName)
                : StringUtils.concat("Deploying: ", contractName, " as ", contractAlias)
        );
        increaseIndent();
        // Check if the contract is already deployed
        deployedAt = tryGetDeploymentAddress(contractAlias);
        if (deployedAt != address(0)) {
            printLog("Skipping: already deployed at %s", deployedAt);
        } else {
            // Trigger callback to deploy the contract
            deployedAt = deployCode(contractName, constructorArgs);
            printLog("Deployed at %s", deployedAt);
            // Save the deployment JSON
            saveDeployment(contractName, contractAlias, deployedAt, constructorArgs);
        }
        decreaseIndent();
    }

    /// @notice Deploys a contract and saves the deployment JSON, if the contract hasn't been deployed yet.
    /// See `deployAndSaveAs` below for more details.
    function deployAndSave(
        string memory contractName,
        function() internal returns (address, bytes memory) deployContract
    ) internal returns (address deployedAt) {
        // Use contractName as contractAlias by default
        return deployAndSaveAs(contractName, contractName, deployContract);
    }

    /// @notice Deploys a contract and saves the deployment JSON, if the contract hasn't been deployed yet.
    /// Needs to be passed a contract-specific function that deploys the contract, that follows this signature:
    /// deployContract() internal returns (address deployedAt, bytes memory constructorArgs);
    /// - Example: deployDefaultPoolCalc() could be used here if defined in the deployment script. Or anything
    /// else that deploys a specific contract, most likely using `new Contract(...);` approach.
    /// - Note: contract should be configured outside of `deployContract`.
    function deployAndSaveAs(
        string memory contractName,
        string memory contractAlias,
        function() internal returns (address, bytes memory) deployContract
    ) internal returns (address deployedAt) {
        printLog(
            contractName.equals(contractAlias)
                ? StringUtils.concat("Deploying: ", contractName)
                : StringUtils.concat("Deploying: ", contractName, " as ", contractAlias)
        );
        increaseIndent();
        // Check if the contract is already deployed
        deployedAt = tryGetDeploymentAddress(contractAlias);
        if (deployedAt != address(0)) {
            printLog("Skipping: already deployed at %s", deployedAt);
        } else {
            // Trigger callback to deploy the specific contract
            bytes memory constructorArgs;
            (deployedAt, constructorArgs) = deployContract();
            printLog("Deployed at %s", deployedAt);
            // Save the deployment JSON
            saveDeployment(contractName, contractAlias, deployedAt, constructorArgs);
        }
        decreaseIndent();
    }

    // ════════════════════════════════════════ ACTIVE CHAIN: WRITING DATA ═════════════════════════════════════════════

    /// @notice Saves the deployment JSON for a contract on a given chain under the specified alias.
    /// Example: contractName = "LinkedPool", contractAlias = "LinkedPool.USDC"
    /// Note: writes to the FRESH deployment path, which is moved to the correct location after the contract is deployed.
    /// Note: requires ffi to be turned on, and jq to be installed.
    function saveDeployment(
        string memory contractName,
        string memory contractAlias,
        address deployedAt,
        bytes memory constructorArgs
    ) internal {
        string memory dataWithoutABI = serializeDeploymentData(deployedAt, constructorArgs);
        saveDeploymentData({
            chain: activeChain,
            contractName: contractName,
            contractAlias: contractAlias,
            dataWithoutABI: dataWithoutABI
        });
    }

    /// @notice Saves the deploy config for a contract on the active chain
    function saveDeployConfig(string memory contractName, string memory data) internal {
        saveDeployConfig({chain: activeChain, contractName: contractName, data: data});
    }

    // ════════════════════════════════════════ ACTIVE CHAIN: READING DATA ═════════════════════════════════════════════

    /// @notice Asserts that a contract is deployed on the active chain by checking its code size.
    function assertContractCodeExists(string memory contractName, address contractAddr) internal view {
        require(getCodeSize(contractAddr) != 0, StringUtils.concat("No code for ", contractName, " on ", activeChain));
    }

    /// @notice Returns the code size for a given address on the active chain.
    function getCodeSize(address contractAddr) internal view returns (uint256 codeSize) {
        // address.code.length is only available in Solidity 0.8.0+
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codeSize := extcodesize(contractAddr)
        }
    }

    /// @notice Returns the deployment address for a contract on the active chain.
    /// Reverts if the contract is not deployed.
    function getDeploymentAddress(string memory contractName) internal returns (address deployment) {
        // Read the deployment address from the deployment JSON
        deployment = getDeploymentAddress({chain: activeChain, contractName: contractName});
        // Verify that the contract is in fact deployed on the active chain
        assertContractCodeExists(contractName, deployment);
    }

    /// @notice Returns the deployment address for a contract on the active chain, if it exists.
    /// Returns address(0), if it doesn't exist.
    function tryGetDeploymentAddress(string memory contractName) internal returns (address deployment) {
        return tryGetDeploymentAddress({chain: activeChain, contractName: contractName});
    }

    /// @notice Returns the deploy config for a contract on the active chain.
    function getDeployConfig(string memory contractName) internal view returns (string memory deployConfigJson) {
        return getDeployConfig({chain: activeChain, contractName: contractName});
    }

    // ══════════════════════════════════════ ACTIVE CHAIN: FILE PATH GETTERS ══════════════════════════════════════════

    /// @notice Returns the path to the SAVED deployment JSON for a contract on the active chain.
    function deploymentPath(string memory contractName) internal view returns (string memory path) {
        return deploymentPath({chain: activeChain, contractName: contractName});
    }

    /// @notice Returns the path to the FRESH deployment JSON for a contract on the active chain.
    function freshDeploymentPath(string memory contractName) internal view returns (string memory path) {
        return freshDeploymentPath({chain: activeChain, contractName: contractName});
    }

    /// @notice Returns the path to the contract deployment config JSON for a contract on the active chain.
    function deployConfigPath(string memory contractName) internal view returns (string memory path) {
        return deployConfigPath({chain: activeChain, contractName: contractName});
    }

    /// @notice Returns the path to the generic contract config file for a contract on the active chain.
    function genericConfigPath(string memory fileName) internal view returns (string memory path) {
        return genericConfigPath({chain: activeChain, fileName: fileName});
    }

    // ══════════════════════════════════════════════ CHAIN ID UTILS ═══════════════════════════════════════════════════

    /// @notice Sets active chain to the one matching block.chainid value.
    /// Reverts if the chain is not supported.
    function loadActiveChain() internal {
        uint256 chainId = blockChainId();
        activeChain = chainNames[chainId];
        require(bytes(activeChain).length != 0, StringUtils.concat("Unknown chainId: ", chainId.fromUint()));
    }

    /// @notice Reads all chain:chainId pairs from the deployments directory,
    /// and saves them in `chainIds` and `chainNames` mappings.
    function loadChainIds() internal {
        // Read all entries in the deployments directory
        VmSafe.DirEntry[] memory entries = vm.readDir("deployments");
        // Iterate over all entries that are directories
        for (uint256 i = 0; i < entries.length; i++) {
            if (!entries[i].isDir) {
                continue;
            }
            // Extract chain name from the path: everything that comes after the last slash
            uint256 lastSlash = entries[i].path.lastIndexOf("/");
            require(lastSlash != StringUtils.NOT_FOUND, StringUtils.concat("Invalid path:", entries[i].path));
            string memory chainName = entries[i].path.suffix(lastSlash + 1);
            uint256 chainId = tryGetChainId(chainName);
            // Only save the chain if it has a valid chainId
            if (chainId != 0) {
                // Sanity check that no duplicates are saved
                require(chainIds[chainName] == 0, StringUtils.concat("Duplicate chain name: ", chainName));
                require(
                    bytes(chainNames[chainId]).length == 0,
                    StringUtils.concat("Duplicate chainId: ", chainId.fromUint())
                );
                chainIds[chainName] = chainId;
                chainNames[chainId] = chainName;
            }
        }
    }

    /// @notice Wrapper for block.chainid, which only exists in Solidity 0.8+
    function blockChainId() internal view returns (uint256 chainId) {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            chainId := chainid()
        }
    }
}
