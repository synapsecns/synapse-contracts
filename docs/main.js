/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={268:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r});var a=n(81),i=n.n(a),s=n(645),o=n.n(s)()(i());o.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),o.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const r=o},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var o={};if(a)for(var r=0;r<this.length;r++){var u=this[r][0];null!=u&&(o[u]=!0)}for(var p=0;p<e.length;p++){var d=[].concat(e[p]);a&&o[d[0]]||(void 0!==s&&(void 0===d[5]||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=s),n&&(d[2]?(d[1]="@media ".concat(d[2]," {").concat(d[1],"}"),d[2]=n):d[2]=n),i&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=i):d[4]="".concat(i)),t.push(d))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},267:(e,t,n)=>{"use strict";var a=Object.freeze({});function i(e){return null==e}function s(e){return null!=e}function o(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function u(e){return null!==e&&"object"==typeof e}var p=Object.prototype.toString;function d(e){return"[object Object]"===p.call(e)}function l(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function y(e){return s(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function m(e){return null==e?"":Array.isArray(e)||d(e)&&e.toString===p?JSON.stringify(e,null,2):String(e)}function c(e){var t=parseFloat(e);return isNaN(t)?e:t}function h(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var f=h("slot,component",!0),b=h("key,ref,slot,slot-scope,is");function T(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var v=Object.prototype.hasOwnProperty;function w(e,t){return v.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,R=g((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),x=g((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),M=/\B([A-Z])/g,A=g((function(e){return e.replace(M,"-$1").toLowerCase()})),I=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function S(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function C(e,t){for(var n in t)e[n]=t[n];return e}function _(e){for(var t={},n=0;n<e.length;n++)e[n]&&C(t,e[n]);return t}function E(e,t,n){}var O=function(e,t,n){return!1},L=function(e){return e};function D(e,t){if(e===t)return!0;var n=u(e),a=u(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return D(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var o=Object.keys(e),r=Object.keys(t);return o.length===r.length&&o.every((function(n){return D(e[n],t[n])}))}catch(e){return!1}}function P(e,t){for(var n=0;n<e.length;n++)if(D(e[n],t))return n;return-1}function F(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var q="data-server-rendered",N=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],B={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:E,parsePlatformTagName:L,mustUseProp:O,async:!0,_lifecycleHooks:$},W=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function j(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function U(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var H,z=new RegExp("[^"+W.source+".$_\\d]"),G="__proto__"in{},V="undefined"!=typeof window,K="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Z=K&&WXEnvironment.platform.toLowerCase(),X=V&&window.navigator.userAgent.toLowerCase(),J=X&&/msie|trident/.test(X),Y=X&&X.indexOf("msie 9.0")>0,Q=X&&X.indexOf("edge/")>0,ee=(X&&X.indexOf("android"),X&&/iphone|ipad|ipod|ios/.test(X)||"ios"===Z),te=(X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X),X&&X.match(/firefox\/(\d+)/)),ne={}.watch,ae=!1;if(V)try{var ie={};Object.defineProperty(ie,"passive",{get:function(){ae=!0}}),window.addEventListener("test-passive",null,ie)}catch(e){}var se=function(){return void 0===H&&(H=!V&&!K&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),H},oe=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return"function"==typeof e&&/native code/.test(e.toString())}var ue,pe="undefined"!=typeof Symbol&&re(Symbol)&&"undefined"!=typeof Reflect&&re(Reflect.ownKeys);ue="undefined"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var de=E,le=0,ye=function(){this.id=le++,this.subs=[]};ye.prototype.addSub=function(e){this.subs.push(e)},ye.prototype.removeSub=function(e){T(this.subs,e)},ye.prototype.depend=function(){ye.target&&ye.target.addDep(this)},ye.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},ye.target=null;var me=[];function ce(e){me.push(e),ye.target=e}function he(){me.pop(),ye.target=me[me.length-1]}var fe=function(e,t,n,a,i,s,o,r){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=r,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},be={child:{configurable:!0}};be.child.get=function(){return this.componentInstance},Object.defineProperties(fe.prototype,be);var Te=function(e){void 0===e&&(e="");var t=new fe;return t.text=e,t.isComment=!0,t};function ve(e){return new fe(void 0,void 0,void 0,String(e))}function we(e){var t=new fe(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var ge=Array.prototype,ke=Object.create(ge);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=ge[e];U(ke,e,(function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];var i,s=t.apply(this,n),o=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&o.observeArray(i),o.dep.notify(),s}))}));var Re=Object.getOwnPropertyNames(ke),xe=!0;function Me(e){xe=e}var Ae=function(e){this.value=e,this.dep=new ye,this.vmCount=0,U(e,"__ob__",this),Array.isArray(e)?(G?function(e,t){e.__proto__=t}(e,ke):function(e,t,n){for(var a=0,i=n.length;a<i;a++){var s=n[a];U(e,s,t[s])}}(e,ke,Re),this.observeArray(e)):this.walk(e)};function Ie(e,t){var n;if(u(e)&&!(e instanceof fe))return w(e,"__ob__")&&e.__ob__ instanceof Ae?n=e.__ob__:xe&&!se()&&(Array.isArray(e)||d(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new Ae(e)),t&&n&&n.vmCount++,n}function Se(e,t,n,a,i){var s=new ye,o=Object.getOwnPropertyDescriptor(e,t);if(!o||!1!==o.configurable){var r=o&&o.get,u=o&&o.set;r&&!u||2!==arguments.length||(n=e[t]);var p=!i&&Ie(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=r?r.call(e):n;return ye.target&&(s.depend(),p&&(p.dep.depend(),Array.isArray(t)&&Ee(t))),t},set:function(t){var a=r?r.call(e):n;t===a||t!=t&&a!=a||r&&!u||(u?u.call(e,t):n=t,p=!i&&Ie(t),s.notify())}})}}function Ce(e,t,n){if(Array.isArray(e)&&l(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var a=e.__ob__;return e._isVue||a&&a.vmCount?n:a?(Se(a.value,t,n),a.dep.notify(),n):(e[t]=n,n)}function _e(e,t){if(Array.isArray(e)&&l(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||w(e,t)&&(delete e[t],n&&n.dep.notify())}}function Ee(e){for(var t=void 0,n=0,a=e.length;n<a;n++)(t=e[n])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Ee(t)}Ae.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)Se(e,t[n])},Ae.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Ie(e[t])};var Oe=B.optionMergeStrategies;function Le(e,t){if(!t)return e;for(var n,a,i,s=pe?Reflect.ownKeys(t):Object.keys(t),o=0;o<s.length;o++)"__ob__"!==(n=s[o])&&(a=e[n],i=t[n],w(e,n)?a!==i&&d(a)&&d(i)&&Le(a,i):Ce(e,n,i));return e}function De(e,t,n){return n?function(){var a="function"==typeof t?t.call(n,n):t,i="function"==typeof e?e.call(n,n):e;return a?Le(a,i):i}:t?e?function(){return Le("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function Pe(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function Fe(e,t,n,a){var i=Object.create(e||null);return t?C(i,t):i}Oe.data=function(e,t,n){return n?De(e,t,n):t&&"function"!=typeof t?e:De(e,t)},$.forEach((function(e){Oe[e]=Pe})),N.forEach((function(e){Oe[e+"s"]=Fe})),Oe.watch=function(e,t,n,a){if(e===ne&&(e=void 0),t===ne&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var i={};for(var s in C(i,e),t){var o=i[s],r=t[s];o&&!Array.isArray(o)&&(o=[o]),i[s]=o?o.concat(r):Array.isArray(r)?r:[r]}return i},Oe.props=Oe.methods=Oe.inject=Oe.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return C(i,e),t&&C(i,t),i},Oe.provide=De;var qe=function(e,t){return void 0===t?e:t};function Ne(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var a,i,s={};if(Array.isArray(n))for(a=n.length;a--;)"string"==typeof(i=n[a])&&(s[R(i)]={type:null});else if(d(n))for(var o in n)i=n[o],s[R(o)]=d(i)?i:{type:i};e.props=s}}(t),function(e,t){var n=e.inject;if(n){var a=e.inject={};if(Array.isArray(n))for(var i=0;i<n.length;i++)a[n[i]]={from:n[i]};else if(d(n))for(var s in n){var o=n[s];a[s]=d(o)?C({from:s},o):{from:o}}}}(t),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];"function"==typeof a&&(t[n]={bind:a,update:a})}}(t),!t._base&&(t.extends&&(e=Ne(e,t.extends,n)),t.mixins))for(var a=0,i=t.mixins.length;a<i;a++)e=Ne(e,t.mixins[a],n);var s,o={};for(s in e)r(s);for(s in t)w(e,s)||r(s);function r(a){var i=Oe[a]||qe;o[a]=i(e[a],t[a],n,a)}return o}function $e(e,t,n,a){if("string"==typeof n){var i=e[t];if(w(i,n))return i[n];var s=R(n);if(w(i,s))return i[s];var o=x(s);return w(i,o)?i[o]:i[n]||i[s]||i[o]}}function Be(e,t,n,a){var i=t[e],s=!w(n,e),o=n[e],r=He(Boolean,i.type);if(r>-1)if(s&&!w(i,"default"))o=!1;else if(""===o||o===A(e)){var u=He(String,i.type);(u<0||r<u)&&(o=!0)}if(void 0===o){o=function(e,t,n){if(w(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof a&&"Function"!==je(t.type)?a.call(e):a}}(a,i,e);var p=xe;Me(!0),Ie(o),Me(p)}return o}var We=/^\s*function (\w+)/;function je(e){var t=e&&e.toString().match(We);return t?t[1]:""}function Ue(e,t){return je(e)===je(t)}function He(e,t){if(!Array.isArray(t))return Ue(t,e)?0:-1;for(var n=0,a=t.length;n<a;n++)if(Ue(t[n],e))return n;return-1}function ze(e,t,n){ce();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Ve(e,a,"errorCaptured hook")}}Ve(e,t,n)}finally{he()}}function Ge(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&y(s)&&!s._handled&&(s.catch((function(e){return ze(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){ze(e,a,i)}return s}function Ve(e,t,n){if(B.errorHandler)try{return B.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Ke(t)}Ke(e)}function Ke(e,t,n){if(!V&&!K||"undefined"==typeof console)throw e;console.error(e)}var Ze,Xe=!1,Je=[],Ye=!1;function Qe(){Ye=!1;var e=Je.slice(0);Je.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&re(Promise)){var et=Promise.resolve();Ze=function(){et.then(Qe),ee&&setTimeout(E)},Xe=!0}else if(J||"undefined"==typeof MutationObserver||!re(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ze="undefined"!=typeof setImmediate&&re(setImmediate)?function(){setImmediate(Qe)}:function(){setTimeout(Qe,0)};else{var tt=1,nt=new MutationObserver(Qe),at=document.createTextNode(String(tt));nt.observe(at,{characterData:!0}),Ze=function(){tt=(tt+1)%2,at.data=String(tt)},Xe=!0}function it(e,t){var n;if(Je.push((function(){if(e)try{e.call(t)}catch(e){ze(e,t,"nextTick")}else n&&n(t)})),Ye||(Ye=!0,Ze()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}var st=new ue;function ot(e){rt(e,st),st.clear()}function rt(e,t){var n,a,i=Array.isArray(e);if(!(!i&&!u(e)||Object.isFrozen(e)||e instanceof fe)){if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(n=e.length;n--;)rt(e[n],t);else for(n=(a=Object.keys(e)).length;n--;)rt(e[a[n]],t)}}var ut=g((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function pt(e,t){function n(){var e=arguments,a=n.fns;if(!Array.isArray(a))return Ge(a,null,arguments,t,"v-on handler");for(var i=a.slice(),s=0;s<i.length;s++)Ge(i[s],null,e,t,"v-on handler")}return n.fns=e,n}function dt(e,t,n,a,s,r){var u,p,d,l;for(u in e)p=e[u],d=t[u],l=ut(u),i(p)||(i(d)?(i(p.fns)&&(p=e[u]=pt(p,r)),o(l.once)&&(p=e[u]=s(l.name,p,l.capture)),n(l.name,p,l.capture,l.passive,l.params)):p!==d&&(d.fns=p,e[u]=d));for(u in t)i(e[u])&&a((l=ut(u)).name,t[u],l.capture)}function lt(e,t,n){var a;e instanceof fe&&(e=e.data.hook||(e.data.hook={}));var r=e[t];function u(){n.apply(this,arguments),T(a.fns,u)}i(r)?a=pt([u]):s(r.fns)&&o(r.merged)?(a=r).fns.push(u):a=pt([r,u]),a.merged=!0,e[t]=a}function yt(e,t,n,a,i){if(s(t)){if(w(t,n))return e[n]=t[n],i||delete t[n],!0;if(w(t,a))return e[n]=t[a],i||delete t[a],!0}return!1}function mt(e){return r(e)?[ve(e)]:Array.isArray(e)?ht(e):void 0}function ct(e){return s(e)&&s(e.text)&&!1===e.isComment}function ht(e,t){var n,a,u,p,d=[];for(n=0;n<e.length;n++)i(a=e[n])||"boolean"==typeof a||(p=d[u=d.length-1],Array.isArray(a)?a.length>0&&(ct((a=ht(a,(t||"")+"_"+n))[0])&&ct(p)&&(d[u]=ve(p.text+a[0].text),a.shift()),d.push.apply(d,a)):r(a)?ct(p)?d[u]=ve(p.text+a):""!==a&&d.push(ve(a)):ct(a)&&ct(p)?d[u]=ve(p.text+a.text):(o(e._isVList)&&s(a.tag)&&i(a.key)&&s(t)&&(a.key="__vlist"+t+"_"+n+"__"),d.push(a)));return d}function ft(e,t){if(e){for(var n=Object.create(null),a=pe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){for(var o=e[s].from,r=t;r;){if(r._provided&&w(r._provided,o)){n[s]=r._provided[o];break}r=r.$parent}if(!r&&"default"in e[s]){var u=e[s].default;n[s]="function"==typeof u?u.call(t):u}}}return n}}function bt(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],o=s.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,s.context!==t&&s.fnContext!==t||!o||null==o.slot)(n.default||(n.default=[])).push(s);else{var r=o.slot,u=n[r]||(n[r]=[]);"template"===s.tag?u.push.apply(u,s.children||[]):u.push(s)}}for(var p in n)n[p].every(Tt)&&delete n[p];return n}function Tt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function vt(e){return e.isComment&&e.asyncFactory}function wt(e,t,n){var i,s=Object.keys(t).length>0,o=e?!!e.$stable:!s,r=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(o&&n&&n!==a&&r===n.$key&&!s&&!n.$hasNormal)return n;for(var u in i={},e)e[u]&&"$"!==u[0]&&(i[u]=gt(t,u,e[u]))}else i={};for(var p in t)p in i||(i[p]=kt(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),U(i,"$stable",o),U(i,"$key",r),U(i,"$hasNormal",s),i}function gt(e,t,n){var a=function(){var e=arguments.length?n.apply(null,arguments):n({}),t=(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:mt(e))&&e[0];return e&&(!t||1===e.length&&t.isComment&&!vt(t))?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function kt(e,t){return function(){return e[t]}}function Rt(e,t){var n,a,i,o,r;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),a=0,i=e.length;a<i;a++)n[a]=t(e[a],a);else if("number"==typeof e)for(n=new Array(e),a=0;a<e;a++)n[a]=t(a+1,a);else if(u(e))if(pe&&e[Symbol.iterator]){n=[];for(var p=e[Symbol.iterator](),d=p.next();!d.done;)n.push(t(d.value,n.length)),d=p.next()}else for(o=Object.keys(e),n=new Array(o.length),a=0,i=o.length;a<i;a++)r=o[a],n[a]=t(e[r],r,a);return s(n)||(n=[]),n._isVList=!0,n}function xt(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=C(C({},a),n)),i=s(n)||("function"==typeof t?t():t)):i=this.$slots[e]||("function"==typeof t?t():t);var o=n&&n.slot;return o?this.$createElement("template",{slot:o},i):i}function Mt(e){return $e(this.$options,"filters",e)||L}function At(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function It(e,t,n,a,i){var s=B.keyCodes[t]||n;return i&&a&&!B.keyCodes[t]?At(i,a):s?At(s,e):a?A(a)!==t:void 0===e}function St(e,t,n,a,i){if(n&&u(n)){var s;Array.isArray(n)&&(n=_(n));var o=function(o){if("class"===o||"style"===o||b(o))s=e;else{var r=e.attrs&&e.attrs.type;s=a||B.mustUseProp(t,r,o)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var u=R(o),p=A(o);u in s||p in s||(s[o]=n[o],i&&((e.on||(e.on={}))["update:"+o]=function(e){n[o]=e}))};for(var r in n)o(r)}return e}function Ct(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||Et(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),a}function _t(e,t,n){return Et(e,"__once__"+t+(n?"_"+n:""),!0),e}function Et(e,t,n){if(Array.isArray(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&Ot(e[a],t+"_"+a,n);else Ot(e,t,n)}function Ot(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function Lt(e,t){if(t&&d(t)){var n=e.on=e.on?C({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function Dt(e,t,n,a){t=t||{$stable:!n};for(var i=0;i<e.length;i++){var s=e[i];Array.isArray(s)?Dt(s,t,n):s&&(s.proxy&&(s.fn.proxy=!0),t[s.key]=s.fn)}return a&&(t.$key=a),t}function Pt(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function Ft(e,t){return"string"==typeof e?t+e:e}function qt(e){e._o=_t,e._n=c,e._s=m,e._l=Rt,e._t=xt,e._q=D,e._i=P,e._m=Ct,e._f=Mt,e._k=It,e._b=St,e._v=ve,e._e=Te,e._u=Dt,e._g=Lt,e._d=Pt,e._p=Ft}function Nt(e,t,n,i,s){var r,u=this,p=s.options;w(i,"_uid")?(r=Object.create(i))._original=i:(r=i,i=i._original);var d=o(p._compiled),l=!d;this.data=e,this.props=t,this.children=n,this.parent=i,this.listeners=e.on||a,this.injections=ft(p.inject,i),this.slots=function(){return u.$slots||wt(e.scopedSlots,u.$slots=bt(n,i)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return wt(e.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=wt(e.scopedSlots,this.$slots)),p._scopeId?this._c=function(e,t,n,a){var s=zt(r,e,t,n,a,l);return s&&!Array.isArray(s)&&(s.fnScopeId=p._scopeId,s.fnContext=i),s}:this._c=function(e,t,n,a){return zt(r,e,t,n,a,l)}}function $t(e,t,n,a,i){var s=we(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Bt(e,t){for(var n in t)e[R(n)]=t[n]}qt(Nt.prototype);var Wt={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Wt.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return s(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,tn)).$mount(t?e.elm:void 0,t)},prepatch:function(e,t){var n=t.componentOptions;!function(e,t,n,i,s){var o=i.data.scopedSlots,r=e.$scopedSlots,u=!!(o&&!o.$stable||r!==a&&!r.$stable||o&&e.$scopedSlots.$key!==o.$key||!o&&e.$scopedSlots.$key),p=!!(s||e.$options._renderChildren||u);if(e.$options._parentVnode=i,e.$vnode=i,e._vnode&&(e._vnode.parent=i),e.$options._renderChildren=s,e.$attrs=i.data.attrs||a,e.$listeners=n||a,t&&e.$options.props){Me(!1);for(var d=e._props,l=e.$options._propKeys||[],y=0;y<l.length;y++){var m=l[y],c=e.$options.props;d[m]=Be(m,c,t,e)}Me(!0),e.$options.propsData=t}n=n||a;var h=e.$options._parentListeners;e.$options._parentListeners=n,en(e,n,h),p&&(e.$slots=bt(s,i.context),e.$forceUpdate())}(t.componentInstance=e.componentInstance,n.propsData,n.listeners,t,n.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,rn(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,pn.push(t)):sn(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?on(t,!0):t.$destroy())}},jt=Object.keys(Wt);function Ut(e,t,n,r,p){if(!i(e)){var d=n.$options._base;if(u(e)&&(e=d.extend(e)),"function"==typeof e){var l;if(i(e.cid)&&(e=function(e,t){if(o(e.error)&&s(e.errorComp))return e.errorComp;if(s(e.resolved))return e.resolved;var n=Kt;if(n&&s(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),o(e.loading)&&s(e.loadingComp))return e.loadingComp;if(n&&!s(e.owners)){var a=e.owners=[n],r=!0,p=null,d=null;n.$on("hook:destroyed",(function(){return T(a,n)}));var l=function(e){for(var t=0,n=a.length;t<n;t++)a[t].$forceUpdate();e&&(a.length=0,null!==p&&(clearTimeout(p),p=null),null!==d&&(clearTimeout(d),d=null))},m=F((function(n){e.resolved=Zt(n,t),r?a.length=0:l(!0)})),c=F((function(t){s(e.errorComp)&&(e.error=!0,l(!0))})),h=e(m,c);return u(h)&&(y(h)?i(e.resolved)&&h.then(m,c):y(h.component)&&(h.component.then(m,c),s(h.error)&&(e.errorComp=Zt(h.error,t)),s(h.loading)&&(e.loadingComp=Zt(h.loading,t),0===h.delay?e.loading=!0:p=setTimeout((function(){p=null,i(e.resolved)&&i(e.error)&&(e.loading=!0,l(!1))}),h.delay||200)),s(h.timeout)&&(d=setTimeout((function(){d=null,i(e.resolved)&&c(null)}),h.timeout)))),r=!1,e.loading?e.loadingComp:e.resolved}}(l=e,d),void 0===e))return function(e,t,n,a,i){var s=Te();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(l,t,n,r,p);t=t||{},Sn(e),s(t.model)&&function(e,t){var n=e.model&&e.model.prop||"value",a=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[n]=t.model.value;var i=t.on||(t.on={}),o=i[a],r=t.model.callback;s(o)?(Array.isArray(o)?-1===o.indexOf(r):o!==r)&&(i[a]=[r].concat(o)):i[a]=r}(e.options,t);var m=function(e,t,n){var a=t.options.props;if(!i(a)){var o={},r=e.attrs,u=e.props;if(s(r)||s(u))for(var p in a){var d=A(p);yt(o,u,p,d,!0)||yt(o,r,p,d,!1)}return o}}(t,e);if(o(e.options.functional))return function(e,t,n,i,o){var r=e.options,u={},p=r.props;if(s(p))for(var d in p)u[d]=Be(d,p,t||a);else s(n.attrs)&&Bt(u,n.attrs),s(n.props)&&Bt(u,n.props);var l=new Nt(n,u,o,i,e),y=r.render.call(null,l._c,l);if(y instanceof fe)return $t(y,n,l.parent,r);if(Array.isArray(y)){for(var m=mt(y)||[],c=new Array(m.length),h=0;h<m.length;h++)c[h]=$t(m[h],n,l.parent,r);return c}}(e,m,t,n,r);var c=t.on;if(t.on=t.nativeOn,o(e.options.abstract)){var h=t.slot;t={},h&&(t.slot=h)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<jt.length;n++){var a=jt[n],i=t[a],s=Wt[a];i===s||i&&i._merged||(t[a]=i?Ht(s,i):s)}}(t);var f=e.options.name||p;return new fe("vue-component-"+e.cid+(f?"-"+f:""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:m,listeners:c,tag:p,children:r},l)}}}function Ht(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}function zt(e,t,n,a,i,p){return(Array.isArray(n)||r(n))&&(i=a,a=n,n=void 0),o(p)&&(i=2),function(e,t,n,a,i){if(s(n)&&s(n.__ob__))return Te();if(s(n)&&s(n.is)&&(t=n.is),!t)return Te();var o,r,p;(Array.isArray(a)&&"function"==typeof a[0]&&((n=n||{}).scopedSlots={default:a[0]},a.length=0),2===i?a=mt(a):1===i&&(a=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(a)),"string"==typeof t)?(r=e.$vnode&&e.$vnode.ns||B.getTagNamespace(t),o=B.isReservedTag(t)?new fe(B.parsePlatformTagName(t),n,a,void 0,void 0,e):n&&n.pre||!s(p=$e(e.$options,"components",t))?new fe(t,n,a,void 0,void 0,e):Ut(p,n,e,a,t)):o=Ut(t,n,e,a);return Array.isArray(o)?o:s(o)?(s(r)&&Gt(o,r),s(n)&&function(e){u(e.style)&&ot(e.style),u(e.class)&&ot(e.class)}(n),o):Te()}(e,t,n,a,i)}function Gt(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),s(e.children))for(var a=0,r=e.children.length;a<r;a++){var u=e.children[a];s(u.tag)&&(i(u.ns)||o(n)&&"svg"!==u.tag)&&Gt(u,t,n)}}var Vt,Kt=null;function Zt(e,t){return(e.__esModule||pe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),u(e)?t.extend(e):e}function Xt(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var n=e[t];if(s(n)&&(s(n.componentOptions)||vt(n)))return n}}function Jt(e,t){Vt.$on(e,t)}function Yt(e,t){Vt.$off(e,t)}function Qt(e,t){var n=Vt;return function a(){var i=t.apply(null,arguments);null!==i&&n.$off(e,a)}}function en(e,t,n){Vt=e,dt(t,n||{},Jt,Yt,Qt,e),Vt=void 0}var tn=null;function nn(e){var t=tn;return tn=e,function(){tn=t}}function an(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function sn(e,t){if(t){if(e._directInactive=!1,an(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)sn(e.$children[n]);rn(e,"activated")}}function on(e,t){if(!(t&&(e._directInactive=!0,an(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)on(e.$children[n]);rn(e,"deactivated")}}function rn(e,t){ce();var n=e.$options[t],a=t+" hook";if(n)for(var i=0,s=n.length;i<s;i++)Ge(n[i],e,null,e,a);e._hasHookEvent&&e.$emit("hook:"+t),he()}var un=[],pn=[],dn={},ln=!1,yn=!1,mn=0,cn=0,hn=Date.now;if(V&&!J){var fn=window.performance;fn&&"function"==typeof fn.now&&hn()>document.createEvent("Event").timeStamp&&(hn=function(){return fn.now()})}function bn(){var e,t;for(cn=hn(),yn=!0,un.sort((function(e,t){return e.id-t.id})),mn=0;mn<un.length;mn++)(e=un[mn]).before&&e.before(),t=e.id,dn[t]=null,e.run();var n=pn.slice(),a=un.slice();mn=un.length=pn.length=0,dn={},ln=yn=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,sn(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a._watcher===n&&a._isMounted&&!a._isDestroyed&&rn(a,"updated")}}(a),oe&&B.devtools&&oe.emit("flush")}var Tn=0,vn=function(e,t,n,a,i){this.vm=e,i&&(e._watcher=this),e._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++Tn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ue,this.newDepIds=new ue,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!z.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=E)),this.value=this.lazy?void 0:this.get()};vn.prototype.get=function(){var e;ce(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;ze(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ot(e),he(),this.cleanupDeps()}return e},vn.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},vn.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},vn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==dn[t]){if(dn[t]=!0,yn){for(var n=un.length-1;n>mn&&un[n].id>e.id;)n--;un.splice(n+1,0,e)}else un.push(e);ln||(ln=!0,it(bn))}}(this)},vn.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||u(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'+this.expression+'"';Ge(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},vn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},vn.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},vn.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||T(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var wn={enumerable:!0,configurable:!0,get:E,set:E};function gn(e,t,n){wn.get=function(){return this[t][n]},wn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,wn)}var kn={lazy:!0};function Rn(e,t,n){var a=!se();"function"==typeof n?(wn.get=a?xn(t):Mn(n),wn.set=E):(wn.get=n.get?a&&!1!==n.cache?xn(t):Mn(n.get):E,wn.set=n.set||E),Object.defineProperty(e,t,wn)}function xn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),ye.target&&t.depend(),t.value}}function Mn(e){return function(){return e.call(this,this)}}function An(e,t,n,a){return d(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}var In=0;function Sn(e){var t=e.options;if(e.super){var n=Sn(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&C(e.extendOptions,a),(t=e.options=Ne(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Cn(e){this._init(e)}function _n(e){return e&&(e.Ctor.options.name||e.tag)}function En(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:(n=e,!("[object RegExp]"!==p.call(n))&&e.test(t));var n}function On(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var o=n[s];if(o){var r=o.name;r&&!t(r)&&Ln(n,s,a,i)}}}function Ln(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,T(n,t)}!function(e){e.prototype._init=function(e){var t=this;t._uid=In++,t._isVue=!0,e&&e._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(t,e):t.$options=Ne(Sn(t.constructor),e||{},t),t._renderProxy=t,t._self=t,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(t),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&en(e,t)}(t),function(e){e._vnode=null,e._staticTrees=null;var t=e.$options,n=e.$vnode=t._parentVnode,i=n&&n.context;e.$slots=bt(t._renderChildren,i),e.$scopedSlots=a,e._c=function(t,n,a,i){return zt(e,t,n,a,i,!1)},e.$createElement=function(t,n,a,i){return zt(e,t,n,a,i,!0)};var s=n&&n.data;Se(e,"$attrs",s&&s.attrs||a,null,!0),Se(e,"$listeners",t._parentListeners||a,null,!0)}(t),rn(t,"beforeCreate"),function(e){var t=ft(e.$options.inject,e);t&&(Me(!1),Object.keys(t).forEach((function(n){Se(e,n,t[n])})),Me(!0))}(t),function(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},a=e._props={},i=e.$options._propKeys=[];e.$parent&&Me(!1);var s=function(s){i.push(s);var o=Be(s,t,n,e);Se(a,s,o),s in e||gn(e,"_props",s)};for(var o in t)s(o);Me(!0)}(e,t.props),t.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?E:I(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;d(t=e._data="function"==typeof t?function(e,t){ce();try{return e.call(t,t)}catch(e){return ze(e,t,"data()"),{}}finally{he()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&w(a,s)||j(s)||gn(e,"_data",s)}Ie(t,!0)}(e):Ie(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=se();for(var i in t){var s=t[i],o="function"==typeof s?s:s.get;a||(n[i]=new vn(e,o||E,E,kn)),i in e||Rn(e,i,s)}}(e,t.computed),t.watch&&t.watch!==ne&&function(e,t){for(var n in t){var a=t[n];if(Array.isArray(a))for(var i=0;i<a.length;i++)An(e,n,a[i]);else An(e,n,a)}}(e,t.watch)}(t),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(t),rn(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(Cn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Ce,e.prototype.$delete=_e,e.prototype.$watch=function(e,t,n){var a=this;if(d(t))return An(a,e,t,n);(n=n||{}).user=!0;var i=new vn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'+i.expression+'"';ce(),Ge(t,a,[i.value],a,s),he()}return function(){i.teardown()}}}(Cn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var a=this;if(Array.isArray(e))for(var i=0,s=e.length;i<s;i++)a.$on(e[i],n);else(a._events[e]||(a._events[e]=[])).push(n),t.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var a=0,i=e.length;a<i;a++)n.$off(e[a],t);return n}var s,o=n._events[e];if(!o)return n;if(!t)return n._events[e]=null,n;for(var r=o.length;r--;)if((s=o[r])===t||s.fn===t){o.splice(r,1);break}return n},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?S(n):n;for(var a=S(arguments,1),i='event handler for "'+e+'"',s=0,o=n.length;s<o;s++)Ge(n[s],t,a,t,i)}return t}}(Cn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=nn(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){rn(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||T(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),rn(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Cn),function(e){qt(e.prototype),e.prototype.$nextTick=function(e){return it(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,a=n.render,i=n._parentVnode;i&&(t.$scopedSlots=wt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Kt=t,e=a.call(t._renderProxy,t.$createElement)}catch(n){ze(n,t,"render"),e=t._vnode}finally{Kt=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof fe||(e=Te()),e.parent=i,e}}(Cn);var Dn=[String,RegExp,Array],Pn={name:"keep-alive",abstract:!0,props:{include:Dn,exclude:Dn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,o=a.componentInstance,r=a.componentOptions;t[i]={name:_n(r),tag:s,componentInstance:o},n.push(i),this.max&&n.length>parseInt(this.max)&&Ln(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Ln(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){On(e,(function(e){return En(t,e)}))})),this.$watch("exclude",(function(t){On(e,(function(e){return!En(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=Xt(e),n=t&&t.componentOptions;if(n){var a=_n(n),i=this.include,s=this.exclude;if(i&&(!a||!En(i,a))||s&&a&&En(s,a))return t;var o=this.cache,r=this.keys,u=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;o[u]?(t.componentInstance=o[u].componentInstance,T(r,u),r.push(u)):(this.vnodeToCache=t,this.keyToCache=u),t.data.keepAlive=!0}return t||e&&e[0]}},Fn={KeepAlive:Pn};!function(e){var t={get:function(){return B}};Object.defineProperty(e,"config",t),e.util={warn:de,extend:C,mergeOptions:Ne,defineReactive:Se},e.set=Ce,e.delete=_e,e.nextTick=it,e.observable=function(e){return Ie(e),e},e.options=Object.create(null),N.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,C(e.options.components,Fn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=S(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Ne(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=e.name||n.options.name,o=function(e){this._init(e)};return(o.prototype=Object.create(n.prototype)).constructor=o,o.cid=t++,o.options=Ne(n.options,e),o.super=n,o.options.props&&function(e){var t=e.options.props;for(var n in t)gn(e.prototype,"_props",n)}(o),o.options.computed&&function(e){var t=e.options.computed;for(var n in t)Rn(e.prototype,n,t[n])}(o),o.extend=n.extend,o.mixin=n.mixin,o.use=n.use,N.forEach((function(e){o[e]=n[e]})),s&&(o.options.components[s]=o),o.superOptions=n.options,o.extendOptions=e,o.sealedOptions=C({},o.options),i[a]=o,o}}(e),function(e){N.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&d(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Cn),Object.defineProperty(Cn.prototype,"$isServer",{get:se}),Object.defineProperty(Cn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Cn,"FunctionalRenderContext",{value:Nt}),Cn.version="2.6.14";var qn=h("style,class"),Nn=h("input,textarea,option,select,progress"),$n=function(e,t,n){return"value"===n&&Nn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Bn=h("contenteditable,draggable,spellcheck"),Wn=h("events,caret,typing,plaintext-only"),jn=h("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Un="http://www.w3.org/1999/xlink",Hn=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},zn=function(e){return Hn(e)?e.slice(6,e.length):""},Gn=function(e){return null==e||!1===e};function Vn(e,t){return{staticClass:Kn(e.staticClass,t.staticClass),class:s(e.class)?[e.class,t.class]:t.class}}function Kn(e,t){return e?t?e+" "+t:e:t||""}function Zn(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,i=e.length;a<i;a++)s(t=Zn(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):u(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Xn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Jn=h("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Yn=h("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Qn=function(e){return Jn(e)||Yn(e)};function ea(e){return Yn(e)?"svg":"math"===e?"math":void 0}var ta=Object.create(null),na=h("text,number,password,search,email,tel,url");function aa(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var ia=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Xn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),sa={create:function(e,t){oa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(oa(e,!0),oa(t))},destroy:function(e){oa(e,!0)}};function oa(e,t){var n=e.data.ref;if(s(n)){var a=e.context,i=e.componentInstance||e.elm,o=a.$refs;t?Array.isArray(o[n])?T(o[n],i):o[n]===i&&(o[n]=void 0):e.data.refInFor?Array.isArray(o[n])?o[n].indexOf(i)<0&&o[n].push(i):o[n]=[i]:o[n]=i}}var ra=new fe("",{},[]),ua=["create","activate","update","remove","destroy"];function pa(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&s(e.data)===s(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=s(n=e.data)&&s(n=n.attrs)&&n.type,i=s(n=t.data)&&s(n=n.attrs)&&n.type;return a===i||na(a)&&na(i)}(e,t)||o(e.isAsyncPlaceholder)&&i(t.asyncFactory.error))}function da(e,t,n){var a,i,o={};for(a=t;a<=n;++a)s(i=e[a].key)&&(o[i]=a);return o}var la={create:ya,update:ya,destroy:function(e){ya(e,ra)}};function ya(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===ra,o=t===ra,r=ca(e.data.directives,e.context),u=ca(t.data.directives,t.context),p=[],d=[];for(n in u)a=r[n],i=u[n],a?(i.oldValue=a.value,i.oldArg=a.arg,fa(i,"update",t,e),i.def&&i.def.componentUpdated&&d.push(i)):(fa(i,"bind",t,e),i.def&&i.def.inserted&&p.push(i));if(p.length){var l=function(){for(var n=0;n<p.length;n++)fa(p[n],"inserted",t,e)};s?lt(t,"insert",l):l()}if(d.length&&lt(t,"postpatch",(function(){for(var n=0;n<d.length;n++)fa(d[n],"componentUpdated",t,e)})),!s)for(n in r)u[n]||fa(r[n],"unbind",e,e,o)}(e,t)}var ma=Object.create(null);function ca(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++)(a=e[n]).modifiers||(a.modifiers=ma),i[ha(a)]=a,a.def=$e(t.$options,"directives",a.name);return i}function ha(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function fa(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){ze(a,n.context,"directive "+e.name+" "+t+" hook")}}var ba=[sa,la];function Ta(e,t){var n=t.componentOptions;if(!(s(n)&&!1===n.Ctor.options.inheritAttrs||i(e.data.attrs)&&i(t.data.attrs))){var a,o,r=t.elm,u=e.data.attrs||{},p=t.data.attrs||{};for(a in s(p.__ob__)&&(p=t.data.attrs=C({},p)),p)o=p[a],u[a]!==o&&va(r,a,o,t.data.pre);for(a in(J||Q)&&p.value!==u.value&&va(r,"value",p.value),u)i(p[a])&&(Hn(a)?r.removeAttributeNS(Un,zn(a)):Bn(a)||r.removeAttribute(a))}}function va(e,t,n,a){a||e.tagName.indexOf("-")>-1?wa(e,t,n):jn(t)?Gn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):Bn(t)?e.setAttribute(t,function(e,t){return Gn(t)||"false"===t?"false":"contenteditable"===e&&Wn(t)?t:"true"}(t,n)):Hn(t)?Gn(n)?e.removeAttributeNS(Un,zn(t)):e.setAttributeNS(Un,t,n):wa(e,t,n)}function wa(e,t,n){if(Gn(n))e.removeAttribute(t);else{if(J&&!Y&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var ga={create:Ta,update:Ta};function ka(e,t){var n=t.elm,a=t.data,o=e.data;if(!(i(a.staticClass)&&i(a.class)&&(i(o)||i(o.staticClass)&&i(o.class)))){var r=function(e){for(var t=e.data,n=e,a=e;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=Vn(a.data,t));for(;s(n=n.parent);)n&&n.data&&(t=Vn(t,n.data));return i=t.staticClass,o=t.class,s(i)||s(o)?Kn(i,Zn(o)):"";var i,o}(t),u=n._transitionClasses;s(u)&&(r=Kn(r,Zn(u))),r!==n._prevClass&&(n.setAttribute("class",r),n._prevClass=r)}}var Ra,xa,Ma,Aa,Ia,Sa,Ca={create:ka,update:ka},_a=/[\w).+\-_$\]]/;function Ea(e){var t,n,a,i,s,o=!1,r=!1,u=!1,p=!1,d=0,l=0,y=0,m=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),o)39===t&&92!==n&&(o=!1);else if(r)34===t&&92!==n&&(r=!1);else if(u)96===t&&92!==n&&(u=!1);else if(p)47===t&&92!==n&&(p=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||d||l||y){switch(t){case 34:r=!0;break;case 39:o=!0;break;case 96:u=!0;break;case 40:y++;break;case 41:y--;break;case 91:l++;break;case 93:l--;break;case 123:d++;break;case 125:d--}if(47===t){for(var c=a-1,h=void 0;c>=0&&" "===(h=e.charAt(c));c--);h&&_a.test(h)||(p=!0)}}else void 0===i?(m=a+1,i=e.slice(0,a).trim()):f();function f(){(s||(s=[])).push(e.slice(m,a).trim()),m=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==m&&f(),s)for(a=0;a<s.length;a++)i=Oa(i,s[a]);return i}function Oa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var a=t.slice(0,n),i=t.slice(n+1);return'_f("'+a+'")('+e+(")"!==i?","+i:i)}function La(e,t){console.error("[Vue compiler]: "+e)}function Da(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Pa(e,t,n,a,i){(e.props||(e.props=[])).push(Ha({name:t,value:n,dynamic:i},a)),e.plain=!1}function Fa(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(Ha({name:t,value:n,dynamic:i},a)),e.plain=!1}function qa(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(Ha({name:t,value:n},a))}function Na(e,t,n,a,i,s,o,r){(e.directives||(e.directives=[])).push(Ha({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:o},r)),e.plain=!1}function $a(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function Ba(e,t,n,i,s,o,r,u){var p;(i=i||a).right?u?t="("+t+")==='click'?'contextmenu':("+t+")":"click"===t&&(t="contextmenu",delete i.right):i.middle&&(u?t="("+t+")==='click'?'mouseup':("+t+")":"click"===t&&(t="mouseup")),i.capture&&(delete i.capture,t=$a("!",t,u)),i.once&&(delete i.once,t=$a("~",t,u)),i.passive&&(delete i.passive,t=$a("&",t,u)),i.native?(delete i.native,p=e.nativeEvents||(e.nativeEvents={})):p=e.events||(e.events={});var d=Ha({value:n.trim(),dynamic:u},r);i!==a&&(d.modifiers=i);var l=p[t];Array.isArray(l)?s?l.unshift(d):l.push(d):p[t]=l?s?[d,l]:[l,d]:d,e.plain=!1}function Wa(e,t,n){var a=ja(e,":"+t)||ja(e,"v-bind:"+t);if(null!=a)return Ea(a);if(!1!==n){var i=ja(e,t);if(null!=i)return JSON.stringify(i)}}function ja(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,o=i.length;s<o;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function Ua(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function Ha(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function za(e,t,n){var a=n||{},i=a.number,s="$$v";a.trim&&(s="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(s="_n("+s+")");var o=Ga(t,s);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+o+"}"}}function Ga(e,t){var n=function(e){if(e=e.trim(),Ra=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Ra-1)return(Aa=e.lastIndexOf("."))>-1?{exp:e.slice(0,Aa),key:'"'+e.slice(Aa+1)+'"'}:{exp:e,key:null};for(xa=e,Aa=Ia=Sa=0;!Ka();)Za(Ma=Va())?Ja(Ma):91===Ma&&Xa(Ma);return{exp:e.slice(0,Ia),key:e.slice(Ia+1,Sa)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function Va(){return xa.charCodeAt(++Aa)}function Ka(){return Aa>=Ra}function Za(e){return 34===e||39===e}function Xa(e){var t=1;for(Ia=Aa;!Ka();)if(Za(e=Va()))Ja(e);else if(91===e&&t++,93===e&&t--,0===t){Sa=Aa;break}}function Ja(e){for(var t=e;!Ka()&&(e=Va())!==t;);}var Ya;function Qa(e,t,n){var a=Ya;return function i(){var s=t.apply(null,arguments);null!==s&&ni(e,i,n,a)}}var ei=Xe&&!(te&&Number(te[1])<=53);function ti(e,t,n,a){if(ei){var i=cn,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}Ya.addEventListener(e,t,ae?{capture:n,passive:a}:n)}function ni(e,t,n,a){(a||Ya).removeEventListener(e,t._wrapper||t,n)}function ai(e,t){if(!i(e.data.on)||!i(t.data.on)){var n=t.data.on||{},a=e.data.on||{};Ya=t.elm,function(e){if(s(e.__r)){var t=J?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}s(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),dt(n,a,ti,ni,Qa,t.context),Ya=void 0}}var ii,si={create:ai,update:ai};function oi(e,t){if(!i(e.data.domProps)||!i(t.data.domProps)){var n,a,o=t.elm,r=e.data.domProps||{},u=t.data.domProps||{};for(n in s(u.__ob__)&&(u=t.data.domProps=C({},u)),r)n in u||(o[n]="");for(n in u){if(a=u[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),a===r[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=a;var p=i(a)?"":String(a);ri(o,p)&&(o.value=p)}else if("innerHTML"===n&&Yn(o.tagName)&&i(o.innerHTML)){(ii=ii||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var d=ii.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;d.firstChild;)o.appendChild(d.firstChild)}else if(a!==r[n])try{o[n]=a}catch(e){}}}}function ri(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(s(a)){if(a.number)return c(n)!==c(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var ui={create:oi,update:oi},pi=g((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function di(e){var t=li(e.style);return e.staticStyle?C(e.staticStyle,t):t}function li(e){return Array.isArray(e)?_(e):"string"==typeof e?pi(e):e}var yi,mi=/^--/,ci=/\s*!important$/,hi=function(e,t,n){if(mi.test(t))e.style.setProperty(t,n);else if(ci.test(n))e.style.setProperty(A(t),n.replace(ci,""),"important");else{var a=bi(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},fi=["Webkit","Moz","ms"],bi=g((function(e){if(yi=yi||document.createElement("div").style,"filter"!==(e=R(e))&&e in yi)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<fi.length;n++){var a=fi[n]+t;if(a in yi)return a}}));function Ti(e,t){var n=t.data,a=e.data;if(!(i(n.staticStyle)&&i(n.style)&&i(a.staticStyle)&&i(a.style))){var o,r,u=t.elm,p=a.staticStyle,d=a.normalizedStyle||a.style||{},l=p||d,y=li(t.data.style)||{};t.data.normalizedStyle=s(y.__ob__)?C({},y):y;var m=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=di(i.data))&&C(a,n);(n=di(e.data))&&C(a,n);for(var s=e;s=s.parent;)s.data&&(n=di(s.data))&&C(a,n);return a}(t);for(r in l)i(m[r])&&hi(u,r,"");for(r in m)(o=m[r])!==l[r]&&hi(u,r,null==o?"":o)}}var vi={create:Ti,update:Ti},wi=/\s+/;function gi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(wi).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function ki(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(wi).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Ri(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&C(t,xi(e.name||"v")),C(t,e),t}return"string"==typeof e?xi(e):void 0}}var xi=g((function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}})),Mi=V&&!Y,Ai="transition",Ii="animation",Si="transition",Ci="transitionend",_i="animation",Ei="animationend";Mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Si="WebkitTransition",Ci="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(_i="WebkitAnimation",Ei="webkitAnimationEnd"));var Oi=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Li(e){Oi((function(){Oi(e)}))}function Di(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),gi(e,t))}function Pi(e,t){e._transitionClasses&&T(e._transitionClasses,t),ki(e,t)}function Fi(e,t,n){var a=Ni(e,t),i=a.type,s=a.timeout,o=a.propCount;if(!i)return n();var r=i===Ai?Ci:Ei,u=0,p=function(){e.removeEventListener(r,d),n()},d=function(t){t.target===e&&++u>=o&&p()};setTimeout((function(){u<o&&p()}),s+1),e.addEventListener(r,d)}var qi=/\b(transform|all)(,|$)/;function Ni(e,t){var n,a=window.getComputedStyle(e),i=(a[Si+"Delay"]||"").split(", "),s=(a[Si+"Duration"]||"").split(", "),o=$i(i,s),r=(a[_i+"Delay"]||"").split(", "),u=(a[_i+"Duration"]||"").split(", "),p=$i(r,u),d=0,l=0;return t===Ai?o>0&&(n=Ai,d=o,l=s.length):t===Ii?p>0&&(n=Ii,d=p,l=u.length):l=(n=(d=Math.max(o,p))>0?o>p?Ai:Ii:null)?n===Ai?s.length:u.length:0,{type:n,timeout:d,propCount:l,hasTransform:n===Ai&&qi.test(a[Si+"Property"])}}function $i(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return Bi(t)+Bi(e[n])})))}function Bi(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Wi(e,t){var n=e.elm;s(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var a=Ri(e.data.transition);if(!i(a)&&!s(n._enterCb)&&1===n.nodeType){for(var o=a.css,r=a.type,p=a.enterClass,d=a.enterToClass,l=a.enterActiveClass,y=a.appearClass,m=a.appearToClass,h=a.appearActiveClass,f=a.beforeEnter,b=a.enter,T=a.afterEnter,v=a.enterCancelled,w=a.beforeAppear,g=a.appear,k=a.afterAppear,R=a.appearCancelled,x=a.duration,M=tn,A=tn.$vnode;A&&A.parent;)M=A.context,A=A.parent;var I=!M._isMounted||!e.isRootInsert;if(!I||g||""===g){var S=I&&y?y:p,C=I&&h?h:l,_=I&&m?m:d,E=I&&w||f,O=I&&"function"==typeof g?g:b,L=I&&k||T,D=I&&R||v,P=c(u(x)?x.enter:x),q=!1!==o&&!Y,N=Hi(O),$=n._enterCb=F((function(){q&&(Pi(n,_),Pi(n,C)),$.cancelled?(q&&Pi(n,S),D&&D(n)):L&&L(n),n._enterCb=null}));e.data.show||lt(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),O&&O(n,$)})),E&&E(n),q&&(Di(n,S),Di(n,C),Li((function(){Pi(n,S),$.cancelled||(Di(n,_),N||(Ui(P)?setTimeout($,P):Fi(n,r,$)))}))),e.data.show&&(t&&t(),O&&O(n,$)),q||N||$()}}}function ji(e,t){var n=e.elm;s(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var a=Ri(e.data.transition);if(i(a)||1!==n.nodeType)return t();if(!s(n._leaveCb)){var o=a.css,r=a.type,p=a.leaveClass,d=a.leaveToClass,l=a.leaveActiveClass,y=a.beforeLeave,m=a.leave,h=a.afterLeave,f=a.leaveCancelled,b=a.delayLeave,T=a.duration,v=!1!==o&&!Y,w=Hi(m),g=c(u(T)?T.leave:T),k=n._leaveCb=F((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(Pi(n,d),Pi(n,l)),k.cancelled?(v&&Pi(n,p),f&&f(n)):(t(),h&&h(n)),n._leaveCb=null}));b?b(R):R()}function R(){k.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),y&&y(n),v&&(Di(n,p),Di(n,l),Li((function(){Pi(n,p),k.cancelled||(Di(n,d),w||(Ui(g)?setTimeout(k,g):Fi(n,r,k)))}))),m&&m(n,k),v||w||k())}}function Ui(e){return"number"==typeof e&&!isNaN(e)}function Hi(e){if(i(e))return!1;var t=e.fns;return s(t)?Hi(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function zi(e,t){!0!==t.data.show&&Wi(t)}var Gi=function(e){var t,n,a={},u=e.modules,p=e.nodeOps;for(t=0;t<ua.length;++t)for(a[ua[t]]=[],n=0;n<u.length;++n)s(u[n][ua[t]])&&a[ua[t]].push(u[n][ua[t]]);function d(e){var t=p.parentNode(e);s(t)&&p.removeChild(t,e)}function l(e,t,n,i,r,u,d){if(s(e.elm)&&s(u)&&(e=u[d]=we(e)),e.isRootInsert=!r,!function(e,t,n,i){var r=e.data;if(s(r)){var u=s(e.componentInstance)&&r.keepAlive;if(s(r=r.hook)&&s(r=r.init)&&r(e,!1),s(e.componentInstance))return y(e,t),m(n,e.elm,i),o(u)&&function(e,t,n,i){for(var o,r=e;r.componentInstance;)if(s(o=(r=r.componentInstance._vnode).data)&&s(o=o.transition)){for(o=0;o<a.activate.length;++o)a.activate[o](ra,r);t.push(r);break}m(n,e.elm,i)}(e,t,n,i),!0}}(e,t,n,i)){var l=e.data,h=e.children,f=e.tag;s(f)?(e.elm=e.ns?p.createElementNS(e.ns,f):p.createElement(f,e),T(e),c(e,h,t),s(l)&&b(e,t),m(n,e.elm,i)):o(e.isComment)?(e.elm=p.createComment(e.text),m(n,e.elm,i)):(e.elm=p.createTextNode(e.text),m(n,e.elm,i))}}function y(e,t){s(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,f(e)?(b(e,t),T(e)):(oa(e),t.push(e))}function m(e,t,n){s(e)&&(s(n)?p.parentNode(n)===e&&p.insertBefore(e,t,n):p.appendChild(e,t))}function c(e,t,n){if(Array.isArray(t))for(var a=0;a<t.length;++a)l(t[a],n,e.elm,null,!0,t,a);else r(e.text)&&p.appendChild(e.elm,p.createTextNode(String(e.text)))}function f(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return s(e.tag)}function b(e,n){for(var i=0;i<a.create.length;++i)a.create[i](ra,e);s(t=e.data.hook)&&(s(t.create)&&t.create(ra,e),s(t.insert)&&n.push(e))}function T(e){var t;if(s(t=e.fnScopeId))p.setStyleScope(e.elm,t);else for(var n=e;n;)s(t=n.context)&&s(t=t.$options._scopeId)&&p.setStyleScope(e.elm,t),n=n.parent;s(t=tn)&&t!==e.context&&t!==e.fnContext&&s(t=t.$options._scopeId)&&p.setStyleScope(e.elm,t)}function v(e,t,n,a,i,s){for(;a<=i;++a)l(n[a],s,e,t,!1,n,a)}function w(e){var t,n,i=e.data;if(s(i))for(s(t=i.hook)&&s(t=t.destroy)&&t(e),t=0;t<a.destroy.length;++t)a.destroy[t](e);if(s(t=e.children))for(n=0;n<e.children.length;++n)w(e.children[n])}function g(e,t,n){for(;t<=n;++t){var a=e[t];s(a)&&(s(a.tag)?(k(a),w(a)):d(a.elm))}}function k(e,t){if(s(t)||s(e.data)){var n,i=a.remove.length+1;for(s(t)?t.listeners+=i:t=function(e,t){function n(){0==--n.listeners&&d(e)}return n.listeners=t,n}(e.elm,i),s(n=e.componentInstance)&&s(n=n._vnode)&&s(n.data)&&k(n,t),n=0;n<a.remove.length;++n)a.remove[n](e,t);s(n=e.data.hook)&&s(n=n.remove)?n(e,t):t()}else d(e.elm)}function R(e,t,n,a){for(var i=n;i<a;i++){var o=t[i];if(s(o)&&pa(e,o))return i}}function x(e,t,n,r,u,d){if(e!==t){s(t.elm)&&s(r)&&(t=r[u]=we(t));var y=t.elm=e.elm;if(o(e.isAsyncPlaceholder))s(t.asyncFactory.resolved)?I(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(o(t.isStatic)&&o(e.isStatic)&&t.key===e.key&&(o(t.isCloned)||o(t.isOnce)))t.componentInstance=e.componentInstance;else{var m,c=t.data;s(c)&&s(m=c.hook)&&s(m=m.prepatch)&&m(e,t);var h=e.children,b=t.children;if(s(c)&&f(t)){for(m=0;m<a.update.length;++m)a.update[m](e,t);s(m=c.hook)&&s(m=m.update)&&m(e,t)}i(t.text)?s(h)&&s(b)?h!==b&&function(e,t,n,a,o){for(var r,u,d,y=0,m=0,c=t.length-1,h=t[0],f=t[c],b=n.length-1,T=n[0],w=n[b],k=!o;y<=c&&m<=b;)i(h)?h=t[++y]:i(f)?f=t[--c]:pa(h,T)?(x(h,T,a,n,m),h=t[++y],T=n[++m]):pa(f,w)?(x(f,w,a,n,b),f=t[--c],w=n[--b]):pa(h,w)?(x(h,w,a,n,b),k&&p.insertBefore(e,h.elm,p.nextSibling(f.elm)),h=t[++y],w=n[--b]):pa(f,T)?(x(f,T,a,n,m),k&&p.insertBefore(e,f.elm,h.elm),f=t[--c],T=n[++m]):(i(r)&&(r=da(t,y,c)),i(u=s(T.key)?r[T.key]:R(T,t,y,c))?l(T,a,e,h.elm,!1,n,m):pa(d=t[u],T)?(x(d,T,a,n,m),t[u]=void 0,k&&p.insertBefore(e,d.elm,h.elm)):l(T,a,e,h.elm,!1,n,m),T=n[++m]);y>c?v(e,i(n[b+1])?null:n[b+1].elm,n,m,b,a):m>b&&g(t,y,c)}(y,h,b,n,d):s(b)?(s(e.text)&&p.setTextContent(y,""),v(y,null,b,0,b.length-1,n)):s(h)?g(h,0,h.length-1):s(e.text)&&p.setTextContent(y,""):e.text!==t.text&&p.setTextContent(y,t.text),s(c)&&s(m=c.hook)&&s(m=m.postpatch)&&m(e,t)}}}function M(e,t,n){if(o(n)&&s(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var A=h("attrs,class,staticClass,staticStyle,key");function I(e,t,n,a){var i,r=t.tag,u=t.data,p=t.children;if(a=a||u&&u.pre,t.elm=e,o(t.isComment)&&s(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(s(u)&&(s(i=u.hook)&&s(i=i.init)&&i(t,!0),s(i=t.componentInstance)))return y(t,n),!0;if(s(r)){if(s(p))if(e.hasChildNodes())if(s(i=u)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==e.innerHTML)return!1}else{for(var d=!0,l=e.firstChild,m=0;m<p.length;m++){if(!l||!I(l,p[m],n,a)){d=!1;break}l=l.nextSibling}if(!d||l)return!1}else c(t,p,n);if(s(u)){var h=!1;for(var f in u)if(!A(f)){h=!0,b(t,n);break}!h&&u.class&&ot(u.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!i(t)){var u,d=!1,y=[];if(i(e))d=!0,l(t,y);else{var m=s(e.nodeType);if(!m&&pa(e,t))x(e,t,y,null,null,r);else{if(m){if(1===e.nodeType&&e.hasAttribute(q)&&(e.removeAttribute(q),n=!0),o(n)&&I(e,t,y))return M(t,y,!0),e;u=e,e=new fe(p.tagName(u).toLowerCase(),{},[],void 0,u)}var c=e.elm,h=p.parentNode(c);if(l(t,y,c._leaveCb?null:h,p.nextSibling(c)),s(t.parent))for(var b=t.parent,T=f(t);b;){for(var v=0;v<a.destroy.length;++v)a.destroy[v](b);if(b.elm=t.elm,T){for(var k=0;k<a.create.length;++k)a.create[k](ra,b);var R=b.data.hook.insert;if(R.merged)for(var A=1;A<R.fns.length;A++)R.fns[A]()}else oa(b);b=b.parent}s(h)?g([e],0,0):s(e.tag)&&w(e)}}return M(t,y,d),t.elm}s(e)&&w(e)}}({nodeOps:ia,modules:[ga,Ca,si,ui,vi,V?{create:zi,activate:zi,remove:function(e,t){!0!==e.data.show?ji(e,t):t()}}:{}].concat(ba)});Y&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&es(e,"input")}));var Vi={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?lt(n,"postpatch",(function(){Vi.componentUpdated(e,t,n)})):Ki(e,t,n.context),e._vOptions=[].map.call(e.options,Ji)):("textarea"===n.tag||na(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Yi),e.addEventListener("compositionend",Qi),e.addEventListener("change",Qi),Y&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Ki(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,Ji);i.some((function(e,t){return!D(e,a[t])}))&&(e.multiple?t.value.some((function(e){return Xi(e,i)})):t.value!==t.oldValue&&Xi(t.value,i))&&es(e,"change")}}};function Ki(e,t,n){Zi(e,t),(J||Q)&&setTimeout((function(){Zi(e,t)}),0)}function Zi(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,o,r=0,u=e.options.length;r<u;r++)if(o=e.options[r],i)s=P(a,Ji(o))>-1,o.selected!==s&&(o.selected=s);else if(D(Ji(o),a))return void(e.selectedIndex!==r&&(e.selectedIndex=r));i||(e.selectedIndex=-1)}}function Xi(e,t){return t.every((function(t){return!D(t,e)}))}function Ji(e){return"_value"in e?e._value:e.value}function Yi(e){e.target.composing=!0}function Qi(e){e.target.composing&&(e.target.composing=!1,es(e.target,"input"))}function es(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function ts(e){return!e.componentInstance||e.data&&e.data.transition?e:ts(e.componentInstance._vnode)}var ns={bind:function(e,t,n){var a=t.value,i=(n=ts(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,Wi(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=ts(n)).data&&n.data.transition?(n.data.show=!0,a?Wi(n,(function(){e.style.display=e.__vOriginalDisplay})):ji(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}},as={model:Vi,show:ns},is={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ss(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?ss(Xt(t.children)):e}function os(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var s in i)t[R(s)]=i[s];return t}function rs(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var us=function(e){return e.tag||vt(e)},ps=function(e){return"show"===e.name},ds={name:"transition",props:is,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(us)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=ss(i);if(!s)return i;if(this._leaving)return rs(e,i);var o="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var u=(s.data||(s.data={})).transition=os(this),p=this._vnode,d=ss(p);if(s.data.directives&&s.data.directives.some(ps)&&(s.data.show=!0),d&&d.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,d)&&!vt(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var l=d.data.transition=C({},u);if("out-in"===a)return this._leaving=!0,lt(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),rs(e,i);if("in-out"===a){if(vt(s))return p;var y,m=function(){y()};lt(u,"afterEnter",m),lt(u,"enterCancelled",m),lt(l,"delayLeave",(function(e){y=e}))}}return i}}},ls=C({tag:String,moveClass:String},is);delete ls.mode;var ys={props:ls,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=nn(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],o=os(this),r=0;r<i.length;r++){var u=i[r];u.tag&&null!=u.key&&0!==String(u.key).indexOf("__vlist")&&(s.push(u),n[u.key]=u,(u.data||(u.data={})).transition=o)}if(a){for(var p=[],d=[],l=0;l<a.length;l++){var y=a[l];y.data.transition=o,y.data.pos=y.elm.getBoundingClientRect(),n[y.key]?p.push(y):d.push(y)}this.kept=e(t,null,p),this.removed=d}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(ms),e.forEach(cs),e.forEach(hs),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Di(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Ci,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Ci,e),n._moveCb=null,Pi(n,t))})}})))},methods:{hasMove:function(e,t){if(!Mi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){ki(n,e)})),gi(n,t),n.style.display="none",this.$el.appendChild(n);var a=Ni(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function ms(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function cs(e){e.data.newPos=e.elm.getBoundingClientRect()}function hs(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate("+a+"px,"+i+"px)",s.transitionDuration="0s"}}var fs={Transition:ds,TransitionGroup:ys};Cn.config.mustUseProp=$n,Cn.config.isReservedTag=Qn,Cn.config.isReservedAttr=qn,Cn.config.getTagNamespace=ea,Cn.config.isUnknownElement=function(e){if(!V)return!0;if(Qn(e))return!1;if(e=e.toLowerCase(),null!=ta[e])return ta[e];var t=document.createElement(e);return e.indexOf("-")>-1?ta[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ta[e]=/HTMLUnknownElement/.test(t.toString())},C(Cn.options.directives,as),C(Cn.options.components,fs),Cn.prototype.__patch__=V?Gi:E,Cn.prototype.$mount=function(e,t){return function(e,t,n){var a;return e.$el=t,e.$options.render||(e.$options.render=Te),rn(e,"beforeMount"),a=function(){e._update(e._render(),n)},new vn(e,a,E,{before:function(){e._isMounted&&!e._isDestroyed&&rn(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,rn(e,"mounted")),e}(this,e=e&&V?aa(e):void 0,t)},V&&setTimeout((function(){B.devtools&&oe&&oe.emit("init",Cn)}),0);var bs,Ts=/\{\{((?:.|\r?\n)+?)\}\}/g,vs=/[-.*+?^${}()|[\]\/\\]/g,ws=g((function(e){var t=e[0].replace(vs,"\\$&"),n=e[1].replace(vs,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),gs={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ja(e,"class");n&&(e.staticClass=JSON.stringify(n));var a=Wa(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}},ks={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ja(e,"style");n&&(e.staticStyle=JSON.stringify(pi(n)));var a=Wa(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},Rs=h("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),xs=h("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ms=h("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),As=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Is=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ss="[a-zA-Z_][\\-\\.0-9_a-zA-Z"+W.source+"]*",Cs="((?:"+Ss+"\\:)?"+Ss+")",_s=new RegExp("^<"+Cs),Es=/^\s*(\/?)>/,Os=new RegExp("^<\\/"+Cs+"[^>]*>"),Ls=/^<!DOCTYPE [^>]+>/i,Ds=/^<!\--/,Ps=/^<!\[/,Fs=h("script,style,textarea",!0),qs={},Ns={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},$s=/&(?:lt|gt|quot|amp|#39);/g,Bs=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Ws=h("pre,textarea",!0),js=function(e,t){return e&&Ws(e)&&"\n"===t[0]};function Us(e,t){var n=t?Bs:$s;return e.replace(n,(function(e){return Ns[e]}))}var Hs,zs,Gs,Vs,Ks,Zs,Xs,Js,Ys=/^@|^v-on:/,Qs=/^v-|^@|^:|^#/,eo=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,to=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,no=/^\(|\)$/g,ao=/^\[.*\]$/,io=/:(.*)$/,so=/^:|^\.|^v-bind:/,oo=/\.[^.\]]+(?=[^\]]*$)/g,ro=/^v-slot(:|$)|^#/,uo=/[\r\n]/,po=/[ \f\t\r\n]+/g,lo=g((function(e){return(bs=bs||document.createElement("div")).innerHTML=e,bs.textContent})),yo="_empty_";function mo(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:vo(t),rawAttrsMap:{},parent:n,children:[]}}function co(e,t){var n;!function(e){var t=Wa(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=Wa(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ja(e,"scope"),e.slotScope=t||ja(e,"slot-scope")):(t=ja(e,"slot-scope"))&&(e.slotScope=t);var n=Wa(e,"slot");if(n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Fa(e,"slot",n,function(e,t){return e.rawAttrsMap[":slot"]||e.rawAttrsMap["v-bind:slot"]||e.rawAttrsMap.slot}(e))),"template"===e.tag){var a=Ua(e,ro);if(a){var i=bo(a),s=i.name,o=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=o,e.slotScope=a.value||yo}}else{var r=Ua(e,ro);if(r){var u=e.scopedSlots||(e.scopedSlots={}),p=bo(r),d=p.name,l=p.dynamic,y=u[d]=mo("template",[],e);y.slotTarget=d,y.slotTargetDynamic=l,y.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=y,!0})),y.slotScope=r.value||yo,e.children=[],e.plain=!1}}}(e),"slot"===(n=e).tag&&(n.slotName=Wa(n,"name")),function(e){var t;(t=Wa(e,"is"))&&(e.component=t),null!=ja(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<Gs.length;a++)e=Gs[a](e,t)||e;return function(e){var t,n,a,i,s,o,r,u,p=e.attrsList;for(t=0,n=p.length;t<n;t++)if(a=i=p[t].name,s=p[t].value,Qs.test(a))if(e.hasBindings=!0,(o=To(a.replace(Qs,"")))&&(a=a.replace(oo,"")),so.test(a))a=a.replace(so,""),s=Ea(s),(u=ao.test(a))&&(a=a.slice(1,-1)),o&&(o.prop&&!u&&"innerHtml"===(a=R(a))&&(a="innerHTML"),o.camel&&!u&&(a=R(a)),o.sync&&(r=Ga(s,"$event"),u?Ba(e,'"update:"+('+a+")",r,null,!1,0,p[t],!0):(Ba(e,"update:"+R(a),r,null,!1,0,p[t]),A(a)!==R(a)&&Ba(e,"update:"+A(a),r,null,!1,0,p[t])))),o&&o.prop||!e.component&&Xs(e.tag,e.attrsMap.type,a)?Pa(e,a,s,p[t],u):Fa(e,a,s,p[t],u);else if(Ys.test(a))a=a.replace(Ys,""),(u=ao.test(a))&&(a=a.slice(1,-1)),Ba(e,a,s,o,!1,0,p[t],u);else{var d=(a=a.replace(Qs,"")).match(io),l=d&&d[1];u=!1,l&&(a=a.slice(0,-(l.length+1)),ao.test(l)&&(l=l.slice(1,-1),u=!0)),Na(e,a,i,s,l,u,o,p[t])}else Fa(e,a,JSON.stringify(s),p[t]),!e.component&&"muted"===a&&Xs(e.tag,e.attrsMap.type,a)&&Pa(e,a,"true",p[t])}(e),e}function ho(e){var t;if(t=ja(e,"v-for")){var n=function(e){var t=e.match(eo);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(no,""),i=a.match(to);return i?(n.alias=a.replace(to,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&C(e,n)}}function fo(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function bo(e){var t=e.name.replace(ro,"");return t||"#"!==e.name[0]&&(t="default"),ao.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function To(e){var t=e.match(oo);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function vo(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var wo=/^xmlns:NS\d+/,go=/^NS\d+:/;function ko(e){return mo(e.tag,e.attrsList.slice(),e.parent)}var Ro,xo,Mo,Ao=[gs,ks,{preTransformNode:function(e,t){if("input"===e.tag){var n,a=e.attrsMap;if(!a["v-model"])return;if((a[":type"]||a["v-bind:type"])&&(n=Wa(e,"type")),a.type||n||!a["v-bind"]||(n="("+a["v-bind"]+").type"),n){var i=ja(e,"v-if",!0),s=i?"&&("+i+")":"",o=null!=ja(e,"v-else",!0),r=ja(e,"v-else-if",!0),u=ko(e);ho(u),qa(u,"type","checkbox"),co(u,t),u.processed=!0,u.if="("+n+")==='checkbox'"+s,fo(u,{exp:u.if,block:u});var p=ko(e);ja(p,"v-for",!0),qa(p,"type","radio"),co(p,t),fo(u,{exp:"("+n+")==='radio'"+s,block:p});var d=ko(e);return ja(d,"v-for",!0),qa(d,":type",n),co(d,t),fo(u,{exp:i,block:d}),o?u.else=!0:r&&(u.elseif=r),u}}}}],Io={model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,o=e.attrsMap.type;if(e.component)return za(e,a,i),!1;if("select"===s)!function(e,t,n){var a='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";Ba(e,"change",a=a+" "+Ga(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===o)!function(e,t,n){var a=n&&n.number,i=Wa(e,"value")||"null",s=Wa(e,"true-value")||"true",o=Wa(e,"false-value")||"false";Pa(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===s?":("+t+")":":_q("+t+","+s+")")),Ba(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+s+"):("+o+");if(Array.isArray($$a)){var $$v="+(a?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Ga(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Ga(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Ga(t,"$$c")+"}",null,!0)}(e,a,i);else if("input"===s&&"radio"===o)!function(e,t,n){var a=n&&n.number,i=Wa(e,"value")||"null";Pa(e,"checked","_q("+t+","+(i=a?"_n("+i+")":i)+")"),Ba(e,"change",Ga(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,o=i.number,r=i.trim,u=!s&&"range"!==a,p=s?"change":"range"===a?"__r":"input",d="$event.target.value";r&&(d="$event.target.value.trim()"),o&&(d="_n("+d+")");var l=Ga(t,d);u&&(l="if($event.target.composing)return;"+l),Pa(e,"value","("+t+")"),Ba(e,p,l,null,!0),(r||o)&&Ba(e,"blur","$forceUpdate()")}(e,a,i);else if(!B.isReservedTag(s))return za(e,a,i),!1;return!0},text:function(e,t){t.value&&Pa(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Pa(e,"innerHTML","_s("+t.value+")",t)}},So={expectHTML:!0,modules:Ao,directives:Io,isPreTag:function(e){return"pre"===e},isUnaryTag:Rs,mustUseProp:$n,canBeLeftOpenTag:xs,isReservedTag:Qn,getTagNamespace:ea,staticKeys:(Mo=Ao,Mo.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(","))},Co=g((function(e){return h("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function _o(e,t){e&&(Ro=Co(t.staticKeys||""),xo=t.isReservedTag||O,Eo(e),Oo(e,!1))}function Eo(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||f(e.tag)||!xo(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(Ro))))}(e),1===e.type){if(!xo(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Eo(a),a.static||(e.static=!1)}if(e.ifConditions)for(var i=1,s=e.ifConditions.length;i<s;i++){var o=e.ifConditions[i].block;Eo(o),o.static||(e.static=!1)}}}function Oo(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Oo(e.children[n],t||!!e.for);if(e.ifConditions)for(var i=1,s=e.ifConditions.length;i<s;i++)Oo(e.ifConditions[i].block,t)}}var Lo=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Do=/\([^)]*?\);*$/,Po=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Fo={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},qo={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},No=function(e){return"if("+e+")return null;"},$o={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:No("$event.target !== $event.currentTarget"),ctrl:No("!$event.ctrlKey"),shift:No("!$event.shiftKey"),alt:No("!$event.altKey"),meta:No("!$event.metaKey"),left:No("'button' in $event && $event.button !== 0"),middle:No("'button' in $event && $event.button !== 1"),right:No("'button' in $event && $event.button !== 2")};function Bo(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var o=Wo(e[s]);e[s]&&e[s].dynamic?i+=s+","+o+",":a+='"'+s+'":'+o+","}return a="{"+a.slice(0,-1)+"}",i?n+"_d("+a+",["+i.slice(0,-1)+"])":n+a}function Wo(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map((function(e){return Wo(e)})).join(",")+"]";var t=Po.test(e.value),n=Lo.test(e.value),a=Po.test(e.value.replace(Do,""));if(e.modifiers){var i="",s="",o=[];for(var r in e.modifiers)if($o[r])s+=$o[r],Fo[r]&&o.push(r);else if("exact"===r){var u=e.modifiers;s+=No(["ctrl","shift","alt","meta"].filter((function(e){return!u[e]})).map((function(e){return"$event."+e+"Key"})).join("||"))}else o.push(r);return o.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(jo).join("&&")+")return null;"}(o)),s&&(i+=s),"function($event){"+i+(t?"return "+e.value+".apply(null, arguments)":n?"return ("+e.value+").apply(null, arguments)":a?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(a?"return "+e.value:e.value)+"}"}function jo(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Fo[e],a=qo[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(a)+")"}var Uo={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:E},Ho=function(e){this.options=e,this.warn=e.warn||La,this.transforms=Da(e.modules,"transformCode"),this.dataGenFns=Da(e.modules,"genData"),this.directives=C(C({},Uo),e.directives);var t=e.isReservedTag||O;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function zo(e,t){var n=new Ho(t);return{render:"with(this){return "+(e?"script"===e.tag?"null":Go(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function Go(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Vo(e,t);if(e.once&&!e.onceProcessed)return Ko(e,t);if(e.for&&!e.forProcessed)return Jo(e,t);if(e.if&&!e.ifProcessed)return Zo(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=tr(e,t),i="_t("+n+(a?",function(){return "+a+"}":""),s=e.attrs||e.dynamicAttrs?ir((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:R(e.name),value:e.value,dynamic:e.dynamic}}))):null,o=e.attrsMap["v-bind"];return!s&&!o||a||(i+=",null"),s&&(i+=","+s),o&&(i+=(s?"":",null")+","+o),i+")"}(e,t);var n;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:tr(t,n,!0);return"_c("+e+","+Yo(t,n)+(a?","+a:"")+")"}(e.component,e,t);else{var a;(!e.plain||e.pre&&t.maybeComponent(e))&&(a=Yo(e,t));var i=e.inlineTemplate?null:tr(e,t,!0);n="_c('"+e.tag+"'"+(a?","+a:"")+(i?","+i:"")+")"}for(var s=0;s<t.transforms.length;s++)n=t.transforms[s](e,n);return n}return tr(e,t)||"void 0"}function Vo(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+Go(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function Ko(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Zo(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o("+Go(e,t)+","+t.onceId+++","+n+")":Go(e,t)}return Vo(e,t)}function Zo(e,t,n,a){return e.ifProcessed=!0,Xo(e.ifConditions.slice(),t,n,a)}function Xo(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"("+i.exp+")?"+s(i.block)+":"+Xo(e,t,n,a):""+s(i.block);function s(e){return n?n(e,t):e.once?Ko(e,t):Go(e,t)}}function Jo(e,t,n,a){var i=e.for,s=e.alias,o=e.iterator1?","+e.iterator1:"",r=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(a||"_l")+"(("+i+"),function("+s+o+r+"){return "+(n||Go)(e,t)+"})"}function Yo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,o,r="directives:[",u=!1;for(a=0,i=n.length;a<i;a++){s=n[a],o=!0;var p=t.directives[s.name];p&&(o=!!p(e,s,t.warn)),o&&(u=!0,r+='{name:"'+s.name+'",rawName:"'+s.rawName+'"'+(s.value?",value:("+s.value+"),expression:"+JSON.stringify(s.value):"")+(s.arg?",arg:"+(s.isDynamicArg?s.arg:'"'+s.arg+'"'):"")+(s.modifiers?",modifiers:"+JSON.stringify(s.modifiers):"")+"},")}return u?r.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:"+ir(e.attrs)+","),e.props&&(n+="domProps:"+ir(e.props)+","),e.events&&(n+=Bo(e.events,!1)+","),e.nativeEvents&&(n+=Bo(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||Qo(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==yo||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var o=Object.keys(t).map((function(e){return er(t[e],n)})).join(",");return"scopedSlots:_u(["+o+"]"+(a?",null,true":"")+(!a&&i?",null,false,"+function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(o):"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=zo(n,t.options);return"inlineTemplate:{render:function(){"+a.render+"},staticRenderFns:["+a.staticRenderFns.map((function(e){return"function(){"+e+"}"})).join(",")+"]}"}}(e,t);s&&(n+=s+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+ir(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function Qo(e){return 1===e.type&&("slot"===e.tag||e.children.some(Qo))}function er(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Zo(e,t,er,"null");if(e.for&&!e.forProcessed)return Jo(e,t,er);var a=e.slotScope===yo?"":String(e.slotScope),i="function("+a+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(tr(e,t)||"undefined")+":undefined":tr(e,t)||"undefined":Go(e,t))+"}",s=a?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+i+s+"}"}function tr(e,t,n,a,i){var s=e.children;if(s.length){var o=s[0];if(1===s.length&&o.for&&"template"!==o.tag&&"slot"!==o.tag){var r=n?t.maybeComponent(o)?",1":",0":"";return""+(a||Go)(o,t)+r}var u=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(nr(i)||i.ifConditions&&i.ifConditions.some((function(e){return nr(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,p=i||ar;return"["+s.map((function(e){return p(e,t)})).join(",")+"]"+(u?","+u:"")}}function nr(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ar(e,t){return 1===e.type?Go(e,t):3===e.type&&e.isComment?function(e){return"_e("+JSON.stringify(e.text)+")"}(e):"_v("+(2===(n=e).type?n.expression:sr(JSON.stringify(n.text)))+")";var n}function ir(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=sr(i.value);i.dynamic?n+=i.name+","+s+",":t+='"'+i.name+'":'+s+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function sr(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function or(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),E}}function rr(e){var t=Object.create(null);return function(n,a,i){(a=C({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var o=e(n,a),r={},u=[];return r.render=or(o.render,u),r.staticRenderFns=o.staticRenderFns.map((function(e){return or(e,u)})),t[s]=r}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var ur,pr,dr=(ur=function(e,t){var n=function(e,t){Hs=t.warn||La,Zs=t.isPreTag||O,Xs=t.mustUseProp||O,Js=t.getTagNamespace||O,t.isReservedTag,Gs=Da(t.modules,"transformNode"),Vs=Da(t.modules,"preTransformNode"),Ks=Da(t.modules,"postTransformNode"),zs=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,o=t.whitespace,r=!1,u=!1;function p(e){if(d(e),r||e.processed||(e=co(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&fo(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)o=e,p=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),p&&p.if&&fo(p,{exp:o.elseif,block:o});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var o,p;e.children=e.children.filter((function(e){return!e.slotScope})),d(e),e.pre&&(r=!1),Zs(e.tag)&&(u=!1);for(var l=0;l<Ks.length;l++)Ks[l](e,t)}function d(e){if(!u)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,o=t.isUnaryTag||O,r=t.canBeLeftOpenTag||O,u=0;e;){if(n=e,a&&Fs(a)){var p=0,d=a.toLowerCase(),l=qs[d]||(qs[d]=new RegExp("([\\s\\S]*?)(</"+d+"[^>]*>)","i")),y=e.replace(l,(function(e,n,a){return p=a.length,Fs(d)||"noscript"===d||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),js(d,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""}));u+=e.length-y.length,e=y,A(d,u-p,u)}else{var m=e.indexOf("<");if(0===m){if(Ds.test(e)){var c=e.indexOf("--\x3e");if(c>=0){t.shouldKeepComment&&t.comment(e.substring(4,c),u,u+c+3),R(c+3);continue}}if(Ps.test(e)){var h=e.indexOf("]>");if(h>=0){R(h+2);continue}}var f=e.match(Ls);if(f){R(f[0].length);continue}var b=e.match(Os);if(b){var T=u;R(b[0].length),A(b[1],T,u);continue}var v=x();if(v){M(v),js(v.tagName,e)&&R(1);continue}}var w=void 0,g=void 0,k=void 0;if(m>=0){for(g=e.slice(m);!(Os.test(g)||_s.test(g)||Ds.test(g)||Ps.test(g)||(k=g.indexOf("<",1))<0);)m+=k,g=e.slice(m);w=e.substring(0,m)}m<0&&(w=e),w&&R(w.length),t.chars&&w&&t.chars(w,u-w.length,u)}if(e===n){t.chars&&t.chars(e);break}}function R(t){u+=t,e=e.substring(t)}function x(){var t=e.match(_s);if(t){var n,a,i={tagName:t[1],attrs:[],start:u};for(R(t[0].length);!(n=e.match(Es))&&(a=e.match(Is)||e.match(As));)a.start=u,R(a[0].length),a.end=u,i.attrs.push(a);if(n)return i.unarySlash=n[1],R(n[0].length),i.end=u,i}}function M(e){var n=e.tagName,u=e.unarySlash;s&&("p"===a&&Ms(n)&&A(a),r(n)&&a===n&&A(n));for(var p=o(n)||!!u,d=e.attrs.length,l=new Array(d),y=0;y<d;y++){var m=e.attrs[y],c=m[3]||m[4]||m[5]||"",h="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;l[y]={name:m[1],value:Us(c,h)}}p||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:l,start:e.start,end:e.end}),a=n),t.start&&t.start(n,l,p,e.start,e.end)}function A(e,n,s){var o,r;if(null==n&&(n=u),null==s&&(s=u),e)for(r=e.toLowerCase(),o=i.length-1;o>=0&&i[o].lowerCasedTag!==r;o--);else o=0;if(o>=0){for(var p=i.length-1;p>=o;p--)t.end&&t.end(i[p].tag,n,s);i.length=o,a=o&&i[o-1].tag}else"br"===r?t.start&&t.start(e,[],!0,n,s):"p"===r&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}A()}(e,{warn:Hs,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,o,d,l){var y=a&&a.ns||Js(e);J&&"svg"===y&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];wo.test(a.name)||(a.name=a.name.replace(go,""),t.push(a))}return t}(s));var m,c=mo(e,s,a);y&&(c.ns=y),"style"!==(m=c).tag&&("script"!==m.tag||m.attrsMap.type&&"text/javascript"!==m.attrsMap.type)||se()||(c.forbidden=!0);for(var h=0;h<Vs.length;h++)c=Vs[h](c,t)||c;r||(function(e){null!=ja(e,"v-pre")&&(e.pre=!0)}(c),c.pre&&(r=!0)),Zs(c.tag)&&(u=!0),r?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(c):c.processed||(ho(c),function(e){var t=ja(e,"v-if");if(t)e.if=t,fo(e,{exp:t,block:e});else{null!=ja(e,"v-else")&&(e.else=!0);var n=ja(e,"v-else-if");n&&(e.elseif=n)}}(c),function(e){null!=ja(e,"v-once")&&(e.once=!0)}(c)),n||(n=c),o?p(c):(a=c,i.push(c))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],p(s)},chars:function(e,t,n){if(a&&(!J||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,p,d,l=a.children;(e=u||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:lo(e):l.length?o?"condense"===o&&uo.test(e)?"":" ":s?" ":"":"")&&(u||"condense"!==o||(e=e.replace(po," ")),!r&&" "!==e&&(p=function(e,t){var n=t?ws(t):Ts;if(n.test(e)){for(var a,i,s,o=[],r=[],u=n.lastIndex=0;a=n.exec(e);){(i=a.index)>u&&(r.push(s=e.slice(u,i)),o.push(JSON.stringify(s)));var p=Ea(a[1].trim());o.push("_s("+p+")"),r.push({"@binding":p}),u=i+a[0].length}return u<e.length&&(r.push(s=e.slice(u)),o.push(JSON.stringify(s))),{expression:o.join("+"),tokens:r}}}(e,zs))?d={type:2,expression:p.expression,tokens:p.tokens,text:e}:" "===e&&l.length&&" "===l[l.length-1].text||(d={type:3,text:e}),d&&l.push(d))}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}(e.trim(),t);!1!==t.optimize&&_o(n,t);var a=zo(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var o in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=C(Object.create(e.directives||null),n.directives)),n)"modules"!==o&&"directives"!==o&&(a[o]=n[o]);a.warn=function(e,t,n){(n?s:i).push(e)};var r=ur(t.trim(),a);return r.errors=i,r.tips=s,r}return{compile:t,compileToFunctions:rr(t)}}),lr=dr(So),yr=(lr.compile,lr.compileToFunctions);function mr(e){return(pr=pr||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',pr.innerHTML.indexOf("&#10;")>0}var cr=!!V&&mr(!1),hr=!!V&&mr(!0),fr=g((function(e){var t=aa(e);return t&&t.innerHTML})),br=Cn.prototype.$mount;Cn.prototype.$mount=function(e,t){if((e=e&&aa(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=fr(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=yr(a,{outputSourceRange:!1,shouldDecodeNewlines:cr,shouldDecodeNewlinesForHref:hr,delimiters:n.delimiters,comments:n.comments},this),s=i.render,o=i.staticRenderFns;n.render=s,n.staticRenderFns=o}}return br.call(this,e,t)},Cn.compile=yr;const Tr=Cn;function vr(e,t){for(var n in t)e[n]=t[n];return e}var wr=/[!'()*]/g,gr=function(e){return"%"+e.charCodeAt(0).toString(16)},kr=/%2C/g,Rr=function(e){return encodeURIComponent(e).replace(wr,gr).replace(kr,",")};function xr(e){try{return decodeURIComponent(e)}catch(e){}return e}var Mr=function(e){return null==e||"object"==typeof e?e:String(e)};function Ar(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=xr(n.shift()),i=n.length>0?xr(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Ir(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return Rr(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(Rr(t)):a.push(Rr(t)+"="+Rr(e)))})),a.join("&")}return Rr(t)+"="+Rr(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Sr=/\/?$/;function Cr(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=_r(s)}catch(e){}var o={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Lr(t,i),matched:e?Or(e):[]};return n&&(o.redirectedFrom=Lr(n,i)),Object.freeze(o)}function _r(e){if(Array.isArray(e))return e.map(_r);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=_r(e[n]);return t}return e}var Er=Cr(null,{path:"/"});function Or(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Lr(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Ir)(a)+i}function Dr(e,t,n){return t===Er?e===t:!!t&&(e.path&&t.path?e.path.replace(Sr,"")===t.path.replace(Sr,"")&&(n||e.hash===t.hash&&Pr(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Pr(e.query,t.query)&&Pr(e.params,t.params)))}function Pr(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var o=t[n];return null==s||null==o?s===o:"object"==typeof s&&"object"==typeof o?Pr(s,o):String(s)===String(o)}))}function Fr(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var o=0;o<s.length;o++)i._isBeingDestroyed||s[o](i)}}}}var qr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var o=i.$createElement,r=n.name,u=i.$route,p=i._routerViewCache||(i._routerViewCache={}),d=0,l=!1;i&&i._routerRoot!==i;){var y=i.$vnode?i.$vnode.data:{};y.routerView&&d++,y.keepAlive&&i._directInactive&&i._inactive&&(l=!0),i=i.$parent}if(s.routerViewDepth=d,l){var m=p[r],c=m&&m.component;return c?(m.configProps&&Nr(c,s,m.route,m.configProps),o(c,s,a)):o()}var h=u.matched[d],f=h&&h.components[r];if(!h||!f)return p[r]=null,o();p[r]={component:f},s.registerRouteInstance=function(e,t){var n=h.instances[r];(t&&n!==e||!t&&n===e)&&(h.instances[r]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){h.instances[r]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==h.instances[r]&&(h.instances[r]=e.componentInstance),Fr(u)};var b=h.props&&h.props[r];return b&&(vr(p[r],{route:u,configProps:b}),Nr(f,s,u,b)),o(f,s,a)}};function Nr(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=vr({},i);var s=t.attrs=t.attrs||{};for(var o in i)e.props&&o in e.props||(s[o]=i[o],delete i[o])}}function $r(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),o=0;o<s.length;o++){var r=s[o];".."===r?i.pop():"."!==r&&i.push(r)}return""!==i[0]&&i.unshift(""),i.join("/")}function Br(e){return e.replace(/\/+/g,"/")}var Wr=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},jr=function e(t,n,a){return Wr(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Qr(e,t)}(t,n):Wr(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return Qr(new RegExp("(?:"+i.join("|")+")",eu(a)),n)}(t,n,a):function(e,t,n){return tu(Vr(e,n),t,n)}(t,n,a)},Ur=Vr,Hr=Xr,zr=tu,Gr=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Vr(e,t){for(var n,a=[],i=0,s=0,o="",r=t&&t.delimiter||"/";null!=(n=Gr.exec(e));){var u=n[0],p=n[1],d=n.index;if(o+=e.slice(s,d),s=d+u.length,p)o+=p[1];else{var l=e[s],y=n[2],m=n[3],c=n[4],h=n[5],f=n[6],b=n[7];o&&(a.push(o),o="");var T=null!=y&&null!=l&&l!==y,v="+"===f||"*"===f,w="?"===f||"*"===f,g=n[2]||r,k=c||h;a.push({name:m||i++,prefix:y||"",delimiter:g,optional:w,repeat:v,partial:T,asterisk:!!b,pattern:k?Yr(k):b?".*":"[^"+Jr(g)+"]+?"})}}return s<e.length&&(o+=e.substr(s)),o&&a.push(o),a}function Kr(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Zr(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Xr(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",eu(t)));return function(t,a){for(var i="",s=t||{},o=(a||{}).pretty?Kr:encodeURIComponent,r=0;r<e.length;r++){var u=e[r];if("string"!=typeof u){var p,d=s[u.name];if(null==d){if(u.optional){u.partial&&(i+=u.prefix);continue}throw new TypeError('Expected "'+u.name+'" to be defined')}if(Wr(d)){if(!u.repeat)throw new TypeError('Expected "'+u.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(u.optional)continue;throw new TypeError('Expected "'+u.name+'" to not be empty')}for(var l=0;l<d.length;l++){if(p=o(d[l]),!n[r].test(p))throw new TypeError('Expected all "'+u.name+'" to match "'+u.pattern+'", but received `'+JSON.stringify(p)+"`");i+=(0===l?u.prefix:u.delimiter)+p}}else{if(p=u.asterisk?Zr(d):o(d),!n[r].test(p))throw new TypeError('Expected "'+u.name+'" to match "'+u.pattern+'", but received "'+p+'"');i+=u.prefix+p}}else i+=u}return i}}function Jr(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Yr(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function Qr(e,t){return e.keys=t,e}function eu(e){return e&&e.sensitive?"":"i"}function tu(e,t,n){Wr(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",o=0;o<e.length;o++){var r=e[o];if("string"==typeof r)s+=Jr(r);else{var u=Jr(r.prefix),p="(?:"+r.pattern+")";t.push(r),r.repeat&&(p+="(?:"+u+p+")*"),s+=p=r.optional?r.partial?u+"("+p+")?":"(?:"+u+"("+p+"))?":u+"("+p+")"}}var d=Jr(n.delimiter||"/"),l=s.slice(-d.length)===d;return a||(s=(l?s.slice(0,-d.length):s)+"(?:"+d+"(?=$))?"),s+=i?"$":a&&l?"":"(?="+d+"|$)",Qr(new RegExp("^"+s,eu(n)),t)}jr.parse=Ur,jr.compile=function(e,t){return Xr(Vr(e,t),t)},jr.tokensToFunction=Hr,jr.tokensToRegExp=zr;var nu=Object.create(null);function au(e,t,n){t=t||{};try{var a=nu[e]||(nu[e]=jr.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function iu(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=vr({},e)).params;return s&&"object"==typeof s&&(i.params=vr({},s)),i}if(!i.path&&i.params&&t){(i=vr({},i))._normalized=!0;var o=vr(vr({},t.params),i.params);if(t.name)i.name=t.name,i.params=o;else if(t.matched.length){var r=t.matched[t.matched.length-1].path;i.path=au(r,o,t.path)}return i}var u=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),p=t&&t.path||"/",d=u.path?$r(u.path,p,n||i.append):p,l=function(e,t,n){void 0===t&&(t={});var a,i=n||Ar;try{a=i(e||"")}catch(e){a={}}for(var s in t){var o=t[s];a[s]=Array.isArray(o)?o.map(Mr):Mr(o)}return a}(u.query,i.query,a&&a.options.parseQuery),y=i.hash||u.hash;return y&&"#"!==y.charAt(0)&&(y="#"+y),{_normalized:!0,path:d,query:l,hash:y}}var su,ou=function(){},ru={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,o=i.route,r=i.href,u={},p=n.options.linkActiveClass,d=n.options.linkExactActiveClass,l=null==p?"router-link-active":p,y=null==d?"router-link-exact-active":d,m=null==this.activeClass?l:this.activeClass,c=null==this.exactActiveClass?y:this.exactActiveClass,h=o.redirectedFrom?Cr(null,iu(o.redirectedFrom),null,n):o;u[c]=Dr(a,h,this.exactPath),u[m]=this.exact||this.exactPath?u[c]:function(e,t){return 0===e.path.replace(Sr,"/").indexOf(t.path.replace(Sr,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,h);var f=u[c]?this.ariaCurrentValue:null,b=function(e){uu(e)&&(t.replace?n.replace(s,ou):n.push(s,ou))},T={click:uu};Array.isArray(this.event)?this.event.forEach((function(e){T[e]=b})):T[this.event]=b;var v={class:u},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:r,route:o,navigate:b,isActive:u[m],isExactActive:u[c]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?e():e("span",{},w)}if("a"===this.tag)v.on=T,v.attrs={href:r,"aria-current":f};else{var g=pu(this.$slots.default);if(g){g.isStatic=!1;var k=g.data=vr({},g.data);for(var R in k.on=k.on||{},k.on){var x=k.on[R];R in T&&(k.on[R]=Array.isArray(x)?x:[x])}for(var M in T)M in k.on?k.on[M].push(T[M]):k.on[M]=b;var A=g.data.attrs=vr({},g.data.attrs);A.href=r,A["aria-current"]=f}else v.on=T}return e(this.tag,v,this.$slots.default)}};function uu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function pu(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=pu(t.children)))return t}}var du="undefined"!=typeof window;function lu(e,t,n,a,i){var s=t||[],o=n||Object.create(null),r=a||Object.create(null);e.forEach((function(e){yu(s,o,r,e,i)}));for(var u=0,p=s.length;u<p;u++)"*"===s[u]&&(s.push(s.splice(u,1)[0]),p--,u--);return{pathList:s,pathMap:o,nameMap:r}}function yu(e,t,n,a,i,s){var o=a.path,r=a.name,u=a.pathToRegexpOptions||{},p=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:Br(t.path+"/"+e)}(o,i,u.strict);"boolean"==typeof a.caseSensitive&&(u.sensitive=a.caseSensitive);var d={path:p,regex:mu(p,u),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:r,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?Br(s+"/"+a.path):void 0;yu(e,t,n,a,d,i)})),t[d.path]||(e.push(d.path),t[d.path]=d),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],y=0;y<l.length;++y){var m={path:l[y],children:a.children};yu(e,t,n,m,i,d.path||"/")}r&&(n[r]||(n[r]=d))}function mu(e,t){return jr(e,[],t)}function cu(e,t){var n=lu(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function o(e,n,o){var u=iu(e,n,!1,t),p=u.name;if(p){var d=s[p];if(!d)return r(null,u);var l=d.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof u.params&&(u.params={}),n&&"object"==typeof n.params)for(var y in n.params)!(y in u.params)&&l.indexOf(y)>-1&&(u.params[y]=n.params[y]);return u.path=au(d.path,u.params),r(d,u,o)}if(u.path){u.params={};for(var m=0;m<a.length;m++){var c=a[m],h=i[c];if(hu(h.regex,u.path,u.params))return r(h,u,o)}}return r(null,u)}function r(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(Cr(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return r(null,n);var u=i,p=u.name,d=u.path,l=n.query,y=n.hash,m=n.params;if(l=u.hasOwnProperty("query")?u.query:l,y=u.hasOwnProperty("hash")?u.hash:y,m=u.hasOwnProperty("params")?u.params:m,p)return s[p],o({_normalized:!0,name:p,query:l,hash:y,params:m},void 0,n);if(d){var c=function(e,t){return $r(e,t.parent?t.parent.path:"/",!0)}(d,e);return o({_normalized:!0,path:au(c,m),query:l,hash:y},void 0,n)}return r(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=o({_normalized:!0,path:au(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,r(s,t)}return r(null,t)}(0,n,e.matchAs):Cr(e,n,a,t)}return{match:o,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;lu([t||e],a,i,s,n),n&&n.alias.length&&lu(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){lu(e,a,i,s)}}}function hu(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var o=e.keys[i-1];o&&(n[o.name||"pathMatch"]="string"==typeof a[i]?xr(a[i]):a[i])}return!0}var fu=du&&window.performance&&window.performance.now?window.performance:Date;function bu(){return fu.now().toFixed(3)}var Tu=bu();function vu(){return Tu}function wu(e){return Tu=e}var gu=Object.create(null);function ku(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=vr({},window.history.state);return n.key=vu(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Mu),function(){window.removeEventListener("popstate",Mu)}}function Ru(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=vu();if(e)return gu[e]}(),o=i.call(e,t,n,a?s:null);o&&("function"==typeof o.then?o.then((function(e){_u(e,s)})).catch((function(e){})):_u(o,s))}))}}function xu(){var e=vu();e&&(gu[e]={x:window.pageXOffset,y:window.pageYOffset})}function Mu(e){xu(),e.state&&e.state.key&&wu(e.state.key)}function Au(e){return Su(e.x)||Su(e.y)}function Iu(e){return{x:Su(e.x)?e.x:window.pageXOffset,y:Su(e.y)?e.y:window.pageYOffset}}function Su(e){return"number"==typeof e}var Cu=/^#\d/;function _u(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Cu.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Su((n=s).x)?n.x:0,y:Su(n.y)?n.y:0})}else Au(e)&&(t=Iu(e))}else a&&Au(e)&&(t=Iu(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Eu,Ou=du&&(-1===(Eu=window.navigator.userAgent).indexOf("Android 2.")&&-1===Eu.indexOf("Android 4.0")||-1===Eu.indexOf("Mobile Safari")||-1!==Eu.indexOf("Chrome")||-1!==Eu.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Lu(e,t){xu();var n=window.history;try{if(t){var a=vr({},n.state);a.key=vu(),n.replaceState(a,"",e)}else n.pushState({key:wu(bu())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Du(e){Lu(e,!0)}function Pu(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}var Fu={redirected:2,aborted:4,cancelled:8,duplicated:16};function qu(e,t){return Nu(e,t,Fu.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Nu(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var $u=["params","query","hash"];function Bu(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Wu(e,t){return Bu(e)&&e._isRouter&&(null==t||e.type===t)}function ju(e,t){return Uu(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function Uu(e){return Array.prototype.concat.apply([],e)}var Hu="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zu(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var Gu=function(e,t){this.router=e,this.base=function(e){if(!e)if(du){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Er,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Vu(e,t,n,a){var i=ju(e,(function(e,a,i,s){var o=function(e,t){return"function"!=typeof e&&(e=su.extend(e)),e.options[t]}(e,t);if(o)return Array.isArray(o)?o.map((function(e){return n(e,a,i,s)})):n(o,a,i,s)}));return Uu(a?i.reverse():i)}function Ku(e,t){if(t)return function(){return e.apply(t,arguments)}}Gu.prototype.listen=function(e){this.cb=e},Gu.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},Gu.prototype.onError=function(e){this.errorCbs.push(e)},Gu.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(Wu(e,Fu.redirected)&&s===Er||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},Gu.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,o,r=function(e){!Wu(e)&&Bu(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},u=e.matched.length-1,p=i.matched.length-1;if(Dr(e,i)&&u===p&&e.matched[u]===i.matched[p])return this.ensureURL(),e.hash&&Ru(this.router,i,e,!1),r(((o=Nu(s=i,e,Fu.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",o));var d,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),y=l.updated,m=l.deactivated,c=l.activated,h=[].concat(function(e){return Vu(e,"beforeRouteLeave",Ku,!0)}(m),this.router.beforeHooks,function(e){return Vu(e,"beforeRouteUpdate",Ku)}(y),c.map((function(e){return e.beforeEnter})),(d=c,function(e,t,n){var a=!1,i=0,s=null;ju(d,(function(e,t,o,r){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var u,p=zu((function(t){var a;((a=t).__esModule||Hu&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:su.extend(t),o.components[r]=t,--i<=0&&n()})),d=zu((function(e){var t="Failed to resolve async component "+r+": "+e;s||(s=Bu(e)?e:new Error(t),n(s))}));try{u=e(p,d)}catch(e){d(e)}if(u)if("function"==typeof u.then)u.then(p,d);else{var l=u.component;l&&"function"==typeof l.then&&l.then(p,d)}}})),a||n()})),f=function(t,n){if(a.pending!==e)return r(qu(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),r(function(e,t){return Nu(e,t,Fu.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):Bu(t)?(a.ensureURL(!0),r(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(r(function(e,t){return Nu(e,t,Fu.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return $u.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){r(e)}};Pu(h,f,(function(){var n=function(e){return Vu(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(c);Pu(n.concat(a.router.resolveHooks),f,(function(){if(a.pending!==e)return r(qu(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Fr(e)}))}))}))},Gu.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},Gu.prototype.setupListeners=function(){},Gu.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Er,this.pending=null};var Zu=function(e){function t(t,n){e.call(this,t,n),this._startLocation=Xu(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Ou&&n;a&&this.listeners.push(ku());var i=function(){var n=e.current,i=Xu(e.base);e.current===Er&&i===e._startLocation||e.transitionTo(i,(function(e){a&&Ru(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Lu(Br(a.base+e.fullPath)),Ru(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Du(Br(a.base+e.fullPath)),Ru(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(Xu(this.base)!==this.current.fullPath){var t=Br(this.base+this.current.fullPath);e?Lu(t):Du(t)}},t.prototype.getCurrentLocation=function(){return Xu(this.base)},t}(Gu);function Xu(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(Br(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var Ju=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=Xu(e);if(!/^\/#/.test(t))return window.location.replace(Br(e+"/#"+t)),!0}(this.base)||Yu()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Ou&&t;n&&this.listeners.push(ku());var a=function(){var t=e.current;Yu()&&e.transitionTo(Qu(),(function(a){n&&Ru(e.router,a,t,!0),Ou||np(a.fullPath)}))},i=Ou?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){tp(e.fullPath),Ru(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){np(e.fullPath),Ru(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;Qu()!==t&&(e?tp(t):np(t))},t.prototype.getCurrentLocation=function(){return Qu()},t}(Gu);function Yu(){var e=Qu();return"/"===e.charAt(0)||(np("/"+e),!1)}function Qu(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function ep(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function tp(e){Ou?Lu(ep(e)):window.location.hash=e}function np(e){Ou?Du(ep(e)):window.location.replace(ep(e))}var ap=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){Wu(e,Fu.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Gu),ip=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=cu(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Ou&&!1!==e.fallback,this.fallback&&(t="hash"),du||(t="abstract"),this.mode=t,t){case"history":this.history=new Zu(this,e.base);break;case"hash":this.history=new Ju(this,e.base,this.fallback);break;case"abstract":this.history=new ap(this,e.base)}},sp={currentRoute:{configurable:!0}};function op(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}ip.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},sp.currentRoute.get=function(){return this.history&&this.history.current},ip.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof Zu||n instanceof Ju){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Ou&&i&&"fullPath"in e&&Ru(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},ip.prototype.beforeEach=function(e){return op(this.beforeHooks,e)},ip.prototype.beforeResolve=function(e){return op(this.resolveHooks,e)},ip.prototype.afterEach=function(e){return op(this.afterHooks,e)},ip.prototype.onReady=function(e,t){this.history.onReady(e,t)},ip.prototype.onError=function(e){this.history.onError(e)},ip.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},ip.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},ip.prototype.go=function(e){this.history.go(e)},ip.prototype.back=function(){this.go(-1)},ip.prototype.forward=function(){this.go(1)},ip.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},ip.prototype.resolve=function(e,t,n){var a=iu(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,o=function(e,t,n){var a="hash"===n?"#"+t:t;return e?Br(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:o,normalizedTo:a,resolved:i}},ip.prototype.getRoutes=function(){return this.matcher.getRoutes()},ip.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Er&&this.history.transitionTo(this.history.getCurrentLocation())},ip.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Er&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(ip.prototype,sp),ip.install=function e(t){if(!e.installed||su!==t){e.installed=!0,su=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",qr),t.component("RouterLink",ru);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},ip.version="3.5.3",ip.isNavigationFailure=Wu,ip.NavigationFailureType=Fu,ip.START_LOCATION=Er,du&&window.Vue&&window.Vue.use(ip);const rp=ip;var up=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[t("router-view")],1)};function pp(e,t,n,a,i,s,o,r){var u,p="function"==typeof e?e.options:e;if(t&&(p.render=t,p.staticRenderFns=n,p._compiled=!0),a&&(p.functional=!0),s&&(p._scopeId="data-v-"+s),o?(u=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(o)},p._ssrRegister=u):i&&(u=r?function(){i.call(this,(p.functional?this.parent:this).$root.$options.shadowRoot)}:i),u)if(p.functional){p._injectStyles=u;var d=p.render;p.render=function(e,t){return u.call(t),d(e,t)}}else{var l=p.beforeCreate;p.beforeCreate=l?[].concat(l,u):[u]}return{exports:e,options:p}}up._withStripped=!0,n(387);var dp=pp({},up,[],!1,null,null,null);dp.options.__file="node_modules/hardhat-docgen/src/App.vue";const lp=dp.exports;var yp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("HeaderBar"),e._v(" "),n("div",{staticClass:"pb-32"},[n("div",{staticClass:"space-y-4"},[n("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),n("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))])]),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?n("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.receive?n("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.fallback?n("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?n("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?n("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?n("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),n("FooterBar")],1)};yp._withStripped=!0;var mp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[n("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};mp._withStripped=!0;const cp=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}');var hp=pp({data:function(){return{repository:cp.cj,name:cp.u2}},methods:{openLink(e){window.open(e,"_blank")}}},mp,[],!1,null,null,null);hp.options.__file="node_modules/hardhat-docgen/src/components/FooterBar.vue";const fp=hp.exports;var bp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[n("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[e._v("\n    <- Go back\n  ")])],1)};bp._withStripped=!0;var Tp=pp({},bp,[],!1,null,null,null);Tp.options.__file="node_modules/hardhat-docgen/src/components/HeaderBar.vue";const vp=Tp.exports;var wp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[n("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),n("div",{staticClass:"space-y-3"},[n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))]),e._v(" "),n("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),n("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};wp._withStripped=!0;var gp=function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.items.length>0?n("ul",[n("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(t,a){return n("li",{key:a},[n("span",{staticClass:"bg-gray-300"},[e._v(e._s(t.type))]),e._v(" "),n("b",[e._v(e._s(t.name||"_"+a))]),t.desc?n("span",[e._v(": "),n("i",[e._v(e._s(t.desc))])]):e._e()])}))],2):e._e()};gp._withStripped=!0;var kp=pp({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},gp,[],!1,null,null,null);kp.options.__file="node_modules/hardhat-docgen/src/components/MemberSection.vue";const Rp={components:{MemberSection:kp.exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}};var xp=pp(Rp,wp,[],!1,null,null,null);xp.options.__file="node_modules/hardhat-docgen/src/components/Member.vue";const Mp=xp.exports;var Ap=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full mt-8"},[n("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(t){return n("Member",{key:t,staticClass:"mt-3",attrs:{json:e.json[t]}})}))],2)};Ap._withStripped=!0;var Ip=pp({components:{Member:Mp},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Ap,[],!1,null,null,null);Ip.options.__file="node_modules/hardhat-docgen/src/components/MemberSet.vue";var Sp=pp({components:{Member:Mp,MemberSet:Ip.exports,HeaderBar:vp,FooterBar:fp},props:{json:{type:Object,default:()=>new Object}}},yp,[],!1,null,null,null);Sp.options.__file="node_modules/hardhat-docgen/src/components/Contract.vue";const Cp=Sp.exports;var _p=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[n("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),n("FooterBar",{staticClass:"mt-20"})],1)};_p._withStripped=!0;var Ep=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?n("div",{staticClass:"pl-5"},e._l(e.json,(function(t,a){return n("div",{key:a},[n("router-link",{attrs:{to:t.source+":"+t.name}},[e._v("\n        "+e._s(t.name)+"\n      ")])],1)})),0):n("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(t){return n("div",{key:t},[n("Branch",{attrs:{json:e.json[t],name:t}})],1)})),0)])};Ep._withStripped=!0;var Op=pp({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Ep,[],!1,null,null,null);Op.options.__file="node_modules/hardhat-docgen/src/components/Branch.vue";var Lp=pp({components:{Branch:Op.exports,FooterBar:fp},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},_p,[],!1,null,null,null);Lp.options.__file="node_modules/hardhat-docgen/src/components/Index.vue";const Dp=Lp.exports;Tr.use(rp);const Pp={"contracts/MultisigWallet/contracts/Factory.sol:Factory":{source:"contracts/MultisigWallet/contracts/Factory.sol",name:"Factory",events:{"ContractInstantiation(address,address)":{anonymous:!1,inputs:[{indexed:!1,name:"sender",type:"address"},{indexed:!1,name:"instantiation",type:"address"}],name:"ContractInstantiation",type:"event"}},methods:{"isInstantiation(address)":{constant:!0,inputs:[{name:"",type:"address"}],name:"isInstantiation",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"instantiations(address,uint256)":{constant:!0,inputs:[{name:"",type:"address"},{name:"",type:"uint256"}],name:"instantiations",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},"getInstantiationCount(address)":{constant:!0,inputs:[{name:"creator",type:"address"}],name:"getInstantiationCount",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of instantiations by creator.",params:{creator:"Contract creator."},return:"Returns number of instantiations by creator."}}},"contracts/MultisigWallet/contracts/Migrations.sol:Migrations":{source:"contracts/MultisigWallet/contracts/Migrations.sol",name:"Migrations",constructor:{inputs:[],payable:!1,stateMutability:"nonpayable",type:"constructor"},methods:{"upgrade(address)":{constant:!1,inputs:[{name:"new_address",type:"address"}],name:"upgrade",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},"last_completed_migration()":{constant:!0,inputs:[],name:"last_completed_migration",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"owner()":{constant:!0,inputs:[],name:"owner",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},"setCompleted(uint256)":{constant:!1,inputs:[{name:"completed",type:"uint256"}],name:"setCompleted",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"}}},"contracts/MultisigWallet/contracts/MultiSigWallet.sol:MultiSigWallet":{source:"contracts/MultisigWallet/contracts/MultiSigWallet.sol",name:"MultiSigWallet",title:"Multisignature wallet - Allows multiple parties to agree on transactions before execution.",author:"Stefan George - <stefan.george@consensys.net>",constructor:{inputs:[{name:"_owners",type:"address[]"},{name:"_required",type:"uint256"}],payable:!1,stateMutability:"nonpayable",type:"constructor"},fallback:{payable:!0,stateMutability:"payable",type:"fallback"},events:{"Confirmation(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"sender",type:"address"},{indexed:!0,name:"transactionId",type:"uint256"}],name:"Confirmation",type:"event"},"Revocation(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"sender",type:"address"},{indexed:!0,name:"transactionId",type:"uint256"}],name:"Revocation",type:"event"},"Submission(uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"transactionId",type:"uint256"}],name:"Submission",type:"event"},"Execution(uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"transactionId",type:"uint256"}],name:"Execution",type:"event"},"ExecutionFailure(uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"transactionId",type:"uint256"}],name:"ExecutionFailure",type:"event"},"Deposit(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"sender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Deposit",type:"event"},"OwnerAddition(address)":{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"}],name:"OwnerAddition",type:"event"},"OwnerRemoval(address)":{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"}],name:"OwnerRemoval",type:"event"},"RequirementChange(uint256)":{anonymous:!1,inputs:[{indexed:!1,name:"required",type:"uint256"}],name:"RequirementChange",type:"event"}},methods:{"owners(uint256)":{constant:!0,inputs:[{name:"",type:"uint256"}],name:"owners",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},"removeOwner(address)":{constant:!1,inputs:[{name:"owner",type:"address"}],name:"removeOwner",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to remove an owner. Transaction has to be sent by wallet.",params:{owner:"Address of owner."}},"revokeConfirmation(uint256)":{constant:!1,inputs:[{name:"transactionId",type:"uint256"}],name:"revokeConfirmation",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows an owner to revoke a confirmation for a transaction.",params:{transactionId:"Transaction ID."}},"isOwner(address)":{constant:!0,inputs:[{name:"",type:"address"}],name:"isOwner",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"confirmations(uint256,address)":{constant:!0,inputs:[{name:"",type:"uint256"},{name:"",type:"address"}],name:"confirmations",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"getTransactionCount(bool,bool)":{constant:!0,inputs:[{name:"pending",type:"bool"},{name:"executed",type:"bool"}],name:"getTransactionCount",outputs:[{name:"count",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns total number of transactions after filers are applied.",params:{executed:"Include executed transactions.",pending:"Include pending transactions."},return:"Total number of transactions after filters are applied."},"addOwner(address)":{constant:!1,inputs:[{name:"owner",type:"address"}],name:"addOwner",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to add a new owner. Transaction has to be sent by wallet.",params:{owner:"Address of new owner."}},"isConfirmed(uint256)":{constant:!0,inputs:[{name:"transactionId",type:"uint256"}],name:"isConfirmed",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function",details:"Returns the confirmation status of a transaction.",params:{transactionId:"Transaction ID."},return:"Confirmation status."},"getConfirmationCount(uint256)":{constant:!0,inputs:[{name:"transactionId",type:"uint256"}],name:"getConfirmationCount",outputs:[{name:"count",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of confirmations of a transaction.",params:{transactionId:"Transaction ID."},return:"Number of confirmations."},"transactions(uint256)":{constant:!0,inputs:[{name:"",type:"uint256"}],name:"transactions",outputs:[{name:"destination",type:"address"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"executed",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"getOwners()":{constant:!0,inputs:[],name:"getOwners",outputs:[{name:"",type:"address[]"}],payable:!1,stateMutability:"view",type:"function",details:"Returns list of owners.",return:"List of owner addresses."},"getTransactionIds(uint256,uint256,bool,bool)":{constant:!0,inputs:[{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"pending",type:"bool"},{name:"executed",type:"bool"}],name:"getTransactionIds",outputs:[{name:"_transactionIds",type:"uint256[]"}],payable:!1,stateMutability:"view",type:"function",details:"Returns list of transaction IDs in defined range.",params:{executed:"Include executed transactions.",from:"Index start position of transaction array.",pending:"Include pending transactions.",to:"Index end position of transaction array."},return:"Returns array of transaction IDs."},"getConfirmations(uint256)":{constant:!0,inputs:[{name:"transactionId",type:"uint256"}],name:"getConfirmations",outputs:[{name:"_confirmations",type:"address[]"}],payable:!1,stateMutability:"view",type:"function",details:"Returns array with owner addresses, which confirmed transaction.",params:{transactionId:"Transaction ID."},return:"Returns array of owner addresses."},"transactionCount()":{constant:!0,inputs:[],name:"transactionCount",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"changeRequirement(uint256)":{constant:!1,inputs:[{name:"_required",type:"uint256"}],name:"changeRequirement",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to change the number of required confirmations. Transaction has to be sent by wallet.",params:{_required:"Number of required confirmations."}},"confirmTransaction(uint256)":{constant:!1,inputs:[{name:"transactionId",type:"uint256"}],name:"confirmTransaction",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows an owner to confirm a transaction.",params:{transactionId:"Transaction ID."}},"submitTransaction(address,uint256,bytes)":{constant:!1,inputs:[{name:"destination",type:"address"},{name:"value",type:"uint256"},{name:"data",type:"bytes"}],name:"submitTransaction",outputs:[{name:"transactionId",type:"uint256"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows an owner to submit and confirm a transaction.",params:{data:"Transaction data payload.",destination:"Transaction target address.",value:"Transaction ether value."},return:"Returns transaction ID."},"MAX_OWNER_COUNT()":{constant:!0,inputs:[],name:"MAX_OWNER_COUNT",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"required()":{constant:!0,inputs:[],name:"required",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"replaceOwner(address,address)":{constant:!1,inputs:[{name:"owner",type:"address"},{name:"newOwner",type:"address"}],name:"replaceOwner",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to replace an owner with a new owner. Transaction has to be sent by wallet.",params:{newOwner:"Address of new owner.",owner:"Address of owner to be replaced."}},"executeTransaction(uint256)":{constant:!1,inputs:[{name:"transactionId",type:"uint256"}],name:"executeTransaction",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows anyone to execute a confirmed transaction.",params:{transactionId:"Transaction ID."}}}},"contracts/MultisigWallet/contracts/MultiSigWalletFactory.sol:MultiSigWalletFactory":{source:"contracts/MultisigWallet/contracts/MultiSigWalletFactory.sol",name:"MultiSigWalletFactory",title:"Multisignature wallet factory - Allows creation of multisig wallet.",author:"Stefan George - <stefan.george@consensys.net>",events:{"ContractInstantiation(address,address)":{anonymous:!1,inputs:[{indexed:!1,name:"sender",type:"address"},{indexed:!1,name:"instantiation",type:"address"}],name:"ContractInstantiation",type:"event"}},methods:{"isInstantiation(address)":{constant:!0,inputs:[{name:"",type:"address"}],name:"isInstantiation",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"instantiations(address,uint256)":{constant:!0,inputs:[{name:"",type:"address"},{name:"",type:"uint256"}],name:"instantiations",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},"getInstantiationCount(address)":{constant:!0,inputs:[{name:"creator",type:"address"}],name:"getInstantiationCount",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of instantiations by creator.",params:{creator:"Contract creator."},return:"Returns number of instantiations by creator."},"create(address[],uint256)":{constant:!1,inputs:[{name:"_owners",type:"address[]"},{name:"_required",type:"uint256"}],name:"create",outputs:[{name:"wallet",type:"address"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows verified creation of multisignature wallet.",params:{_owners:"List of initial owners.",_required:"Number of required confirmations."},return:"Returns wallet address."}}},"contracts/MultisigWallet/contracts/MultiSigWalletWithDailyLimit.sol:MultiSigWalletWithDailyLimit":{source:"contracts/MultisigWallet/contracts/MultiSigWalletWithDailyLimit.sol",name:"MultiSigWalletWithDailyLimit",title:"Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig.",author:"Stefan George - <stefan.george@consensys.net>",constructor:{inputs:[{name:"_owners",type:"address[]"},{name:"_required",type:"uint256"},{name:"_dailyLimit",type:"uint256"}],payable:!1,stateMutability:"nonpayable",type:"constructor"},fallback:{payable:!0,stateMutability:"payable",type:"fallback"},events:{"DailyLimitChange(uint256)":{anonymous:!1,inputs:[{indexed:!1,name:"dailyLimit",type:"uint256"}],name:"DailyLimitChange",type:"event"},"Confirmation(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"sender",type:"address"},{indexed:!0,name:"transactionId",type:"uint256"}],name:"Confirmation",type:"event"},"Revocation(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"sender",type:"address"},{indexed:!0,name:"transactionId",type:"uint256"}],name:"Revocation",type:"event"},"Submission(uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"transactionId",type:"uint256"}],name:"Submission",type:"event"},"Execution(uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"transactionId",type:"uint256"}],name:"Execution",type:"event"},"ExecutionFailure(uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"transactionId",type:"uint256"}],name:"ExecutionFailure",type:"event"},"Deposit(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"sender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Deposit",type:"event"},"OwnerAddition(address)":{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"}],name:"OwnerAddition",type:"event"},"OwnerRemoval(address)":{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"}],name:"OwnerRemoval",type:"event"},"RequirementChange(uint256)":{anonymous:!1,inputs:[{indexed:!1,name:"required",type:"uint256"}],name:"RequirementChange",type:"event"}},methods:{"owners(uint256)":{constant:!0,inputs:[{name:"",type:"uint256"}],name:"owners",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},"removeOwner(address)":{constant:!1,inputs:[{name:"owner",type:"address"}],name:"removeOwner",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to remove an owner. Transaction has to be sent by wallet.",params:{owner:"Address of owner."}},"revokeConfirmation(uint256)":{constant:!1,inputs:[{name:"transactionId",type:"uint256"}],name:"revokeConfirmation",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows an owner to revoke a confirmation for a transaction.",params:{transactionId:"Transaction ID."}},"isOwner(address)":{constant:!0,inputs:[{name:"",type:"address"}],name:"isOwner",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"confirmations(uint256,address)":{constant:!0,inputs:[{name:"",type:"uint256"},{name:"",type:"address"}],name:"confirmations",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"calcMaxWithdraw()":{constant:!0,inputs:[],name:"calcMaxWithdraw",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns maximum withdraw amount.",return:"Returns amount."},"getTransactionCount(bool,bool)":{constant:!0,inputs:[{name:"pending",type:"bool"},{name:"executed",type:"bool"}],name:"getTransactionCount",outputs:[{name:"count",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns total number of transactions after filers are applied.",params:{executed:"Include executed transactions.",pending:"Include pending transactions."},return:"Total number of transactions after filters are applied."},"dailyLimit()":{constant:!0,inputs:[],name:"dailyLimit",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"lastDay()":{constant:!0,inputs:[],name:"lastDay",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"addOwner(address)":{constant:!1,inputs:[{name:"owner",type:"address"}],name:"addOwner",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to add a new owner. Transaction has to be sent by wallet.",params:{owner:"Address of new owner."}},"isConfirmed(uint256)":{constant:!0,inputs:[{name:"transactionId",type:"uint256"}],name:"isConfirmed",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function",details:"Returns the confirmation status of a transaction.",params:{transactionId:"Transaction ID."},return:"Confirmation status."},"getConfirmationCount(uint256)":{constant:!0,inputs:[{name:"transactionId",type:"uint256"}],name:"getConfirmationCount",outputs:[{name:"count",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of confirmations of a transaction.",params:{transactionId:"Transaction ID."},return:"Number of confirmations."},"transactions(uint256)":{constant:!0,inputs:[{name:"",type:"uint256"}],name:"transactions",outputs:[{name:"destination",type:"address"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"executed",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"getOwners()":{constant:!0,inputs:[],name:"getOwners",outputs:[{name:"",type:"address[]"}],payable:!1,stateMutability:"view",type:"function",details:"Returns list of owners.",return:"List of owner addresses."},"getTransactionIds(uint256,uint256,bool,bool)":{constant:!0,inputs:[{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"pending",type:"bool"},{name:"executed",type:"bool"}],name:"getTransactionIds",outputs:[{name:"_transactionIds",type:"uint256[]"}],payable:!1,stateMutability:"view",type:"function",details:"Returns list of transaction IDs in defined range.",params:{executed:"Include executed transactions.",from:"Index start position of transaction array.",pending:"Include pending transactions.",to:"Index end position of transaction array."},return:"Returns array of transaction IDs."},"getConfirmations(uint256)":{constant:!0,inputs:[{name:"transactionId",type:"uint256"}],name:"getConfirmations",outputs:[{name:"_confirmations",type:"address[]"}],payable:!1,stateMutability:"view",type:"function",details:"Returns array with owner addresses, which confirmed transaction.",params:{transactionId:"Transaction ID."},return:"Returns array of owner addresses."},"transactionCount()":{constant:!0,inputs:[],name:"transactionCount",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"changeRequirement(uint256)":{constant:!1,inputs:[{name:"_required",type:"uint256"}],name:"changeRequirement",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to change the number of required confirmations. Transaction has to be sent by wallet.",params:{_required:"Number of required confirmations."}},"confirmTransaction(uint256)":{constant:!1,inputs:[{name:"transactionId",type:"uint256"}],name:"confirmTransaction",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows an owner to confirm a transaction.",params:{transactionId:"Transaction ID."}},"submitTransaction(address,uint256,bytes)":{constant:!1,inputs:[{name:"destination",type:"address"},{name:"value",type:"uint256"},{name:"data",type:"bytes"}],name:"submitTransaction",outputs:[{name:"transactionId",type:"uint256"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows an owner to submit and confirm a transaction.",params:{data:"Transaction data payload.",destination:"Transaction target address.",value:"Transaction ether value."},return:"Returns transaction ID."},"changeDailyLimit(uint256)":{constant:!1,inputs:[{name:"_dailyLimit",type:"uint256"}],name:"changeDailyLimit",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to change the daily limit. Transaction has to be sent by wallet.",params:{_dailyLimit:"Amount in wei."}},"MAX_OWNER_COUNT()":{constant:!0,inputs:[],name:"MAX_OWNER_COUNT",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"required()":{constant:!0,inputs:[],name:"required",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"replaceOwner(address,address)":{constant:!1,inputs:[{name:"owner",type:"address"},{name:"newOwner",type:"address"}],name:"replaceOwner",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows to replace an owner with a new owner. Transaction has to be sent by wallet.",params:{newOwner:"Address of new owner.",owner:"Address of owner to be replaced."}},"executeTransaction(uint256)":{constant:!1,inputs:[{name:"transactionId",type:"uint256"}],name:"executeTransaction",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached.",params:{transactionId:"Transaction ID."}},"spentToday()":{constant:!0,inputs:[],name:"spentToday",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"}}},"contracts/MultisigWallet/contracts/MultiSigWalletWithDailyLimitFactory.sol:MultiSigWalletWithDailyLimitFactory":{source:"contracts/MultisigWallet/contracts/MultiSigWalletWithDailyLimitFactory.sol",name:"MultiSigWalletWithDailyLimitFactory",title:"Multisignature wallet factory for daily limit version - Allows creation of multisig wallet.",author:"Stefan George - <stefan.george@consensys.net>",events:{"ContractInstantiation(address,address)":{anonymous:!1,inputs:[{indexed:!1,name:"sender",type:"address"},{indexed:!1,name:"instantiation",type:"address"}],name:"ContractInstantiation",type:"event"}},methods:{"isInstantiation(address)":{constant:!0,inputs:[{name:"",type:"address"}],name:"isInstantiation",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},"create(address[],uint256,uint256)":{constant:!1,inputs:[{name:"_owners",type:"address[]"},{name:"_required",type:"uint256"},{name:"_dailyLimit",type:"uint256"}],name:"create",outputs:[{name:"wallet",type:"address"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows verified creation of multisignature wallet.",params:{_dailyLimit:"Amount in wei, which can be withdrawn without confirmations on a daily basis.",_owners:"List of initial owners.",_required:"Number of required confirmations."},return:"Returns wallet address."},"instantiations(address,uint256)":{constant:!0,inputs:[{name:"",type:"address"},{name:"",type:"uint256"}],name:"instantiations",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},"getInstantiationCount(address)":{constant:!0,inputs:[{name:"creator",type:"address"}],name:"getInstantiationCount",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of instantiations by creator.",params:{creator:"Contract creator."},return:"Returns number of instantiations by creator."}}},"contracts/MultisigWallet/contracts/TestCalls.sol:TestCalls":{source:"contracts/MultisigWallet/contracts/TestCalls.sol",name:"TestCalls",title:"Contract for testing low-level calls issued from the multisig wallet",constructor:{inputs:[],payable:!1,stateMutability:"nonpayable",type:"constructor"},methods:{"lastMsgValue()":{constant:!0,inputs:[],name:"lastMsgValue",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"nonPayable()":{constant:!1,inputs:[],name:"nonPayable",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},"uint1()":{constant:!0,inputs:[],name:"uint1",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"lastMsgDataLength()":{constant:!0,inputs:[],name:"lastMsgDataLength",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"byteArray1()":{constant:!0,inputs:[],name:"byteArray1",outputs:[{name:"",type:"bytes"}],payable:!1,stateMutability:"view",type:"function"},"receive2uints(uint256,uint256)":{constant:!1,inputs:[{name:"a",type:"uint256"},{name:"b",type:"uint256"}],name:"receive2uints",outputs:[],payable:!0,stateMutability:"payable",type:"function"},"receive1bytes(bytes)":{constant:!1,inputs:[{name:"c",type:"bytes"}],name:"receive1bytes",outputs:[],payable:!0,stateMutability:"payable",type:"function"},"uint2()":{constant:!0,inputs:[],name:"uint2",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"receive1uint(uint256)":{constant:!1,inputs:[{name:"a",type:"uint256"}],name:"receive1uint",outputs:[],payable:!0,stateMutability:"payable",type:"function"}}},"contracts/MultisigWallet/contracts/TestToken.sol:TestToken":{source:"contracts/MultisigWallet/contracts/TestToken.sol",name:"TestToken",title:"Test token contract - Allows testing of token transfers with multisig wallet.",events:{"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"}},methods:{"name()":{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},"approve(address,uint256)":{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"success",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Sets approved amount of tokens for spender. Returns success.",params:{_spender:"Address of allowed account.",_value:"Number of approved tokens."},return:"Returns success of function call."},"totalSupply()":{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"transferFrom(address,address,uint256)":{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"success",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Allows allowed third party to transfer tokens from one address to another. Returns success.",params:{_from:"Address from where tokens are withdrawn.",_to:"Address to where tokens are sent.",_value:"Number of tokens to transfer."},return:"Returns success of function call."},"decimals()":{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},"issueTokens(address,uint256)":{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"issueTokens",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function",details:"Issues new tokens.",params:{_to:"Address of token receiver.",_value:"Number of tokens to issue."}},"balanceOf(address)":{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of tokens owned by given address.",params:{_owner:"Address of token owner."},return:"Returns balance of owner."},"symbol()":{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},"transfer(address,uint256)":{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"success",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function",details:"Transfers sender's tokens to a given address. Returns success.",params:{_to:"Address of token receiver.",_value:"Number of tokens to transfer."},return:"Returns success of function call."},"allowance(address,address)":{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"remaining",type:"uint256"}],payable:!1,stateMutability:"view",type:"function",details:"Returns number of allowed tokens for given address.",params:{_owner:"Address of token owner.",_spender:"Address of token spender."},return:"Returns remaining allowance for spender."}}},"contracts/amm/AaveSwap.sol:AaveSwap":{source:"contracts/amm/AaveSwap.sol",name:"AaveSwap",title:"AaveSwap - A StableSwap implementation in solidity, integrated with Aave.",details:"Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's deployment size.",notice:"This contract is responsible for custody of closely pegged assets (eg. group of stablecoins) and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens in desired ratios for an exchange of the pool token that represents their share of the pool. Users can burn pool tokens and withdraw their share of token(s). Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets distributed to the LPs. In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which stops the ratio of the tokens in the pool from changing. Users can always withdraw their tokens via multi-asset withdraws.",events:{"AddLiquidity(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"AddLiquidity",type:"event"},"NewAdminFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"NewAdminFee",type:"event"},"NewSwapFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"NewSwapFee",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RampA(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"initialTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"futureTime",type:"uint256"}],name:"RampA",type:"event"},"RemoveLiquidity(address,uint256[],uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidity",type:"event"},"RemoveLiquidityImbalance(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidityImbalance",type:"event"},"RemoveLiquidityOne(address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256",name:"lpTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"},{indexed:!1,internalType:"uint256",name:"boughtId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"}],name:"RemoveLiquidityOne",type:"event"},"StopRampA(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"currentA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"time",type:"uint256"}],name:"StopRampA",type:"event"},"TokenSwap(address,uint256,uint256,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"buyer",type:"address"},{indexed:!1,internalType:"uint256",name:"tokensSold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"},{indexed:!1,internalType:"uint128",name:"soldId",type:"uint128"},{indexed:!1,internalType:"uint128",name:"boughtId",type:"uint128"}],name:"TokenSwap",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"the amounts of each token to add, in their native precision",deadline:"latest timestamp to accept this transaction",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation"},returns:{_0:"amount of LP token user minted and received"},notice:"Add liquidity to the pool with the given amounts of tokens"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{amount:"the amount of LP tokens that would be burned on withdrawal"},returns:{_0:"array of token balances that the user will receive"},notice:"A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function",params:{tokenAmount:"the amount of LP token to burn",tokenIndex:"index of which token will be withdrawn"},returns:{availableTokenAmount:"calculated amount of underlying token available to withdraw"},notice:"Calculate the amount of underlying token available to withdraw when withdrawing via only single token"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This shouldn't be used outside frontends for user estimates.",params:{amounts:"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.",deposit:"whether this is a deposit or a withdrawal"},returns:{_0:"token amount the user will receive"},notice:'A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running'},"claimAaveRewards()":{inputs:[],name:"claimAaveRewards",outputs:[],stateMutability:"nonpayable",type:"function"},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See the StableSwap paper for details",returns:{_0:"A parameter"},notice:"Return A, the amplification coefficient * n * (n - 1)"},"getAPrecise()":{inputs:[],name:"getAPrecise",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See the StableSwap paper for details",returns:{_0:"A parameter in its raw precision form"},notice:"Return A in its raw precision form"},"getAdminBalance(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getAdminBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{index:"Index of the pooled token"},returns:{_0:"admin's token balance in the token's precision"},notice:"This function reads the accumulated amount of admin fees of the token with given index"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"address of the token at given index"},notice:"Return address of the pooled token at given index. Reverts if tokenIndex is out of range."},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"current balance of the pooled token at given index with token's native precision"},notice:"Return current balance of the pooled token at given index"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{tokenAddress:"address of the token"},returns:{_0:"the index of the given token address"},notice:"Return the index of the given token address. Reverts if no matching token is found."},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"the virtual price, scaled to the POOL_PRECISION_DECIMALS"},notice:"Get the virtual price, to help calculate profit"},"initialize(address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"contract IERC20[]",name:"_pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"_a",type:"uint256"},{internalType:"uint256",name:"_fee",type:"uint256"},{internalType:"uint256",name:"_adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_a:"the amplification coefficient * n * (n - 1). See the StableSwap paper for details",_adminFee:"default adminFee to be initialized with",_fee:"default swap fee to be initialized with",_pooledTokens:"an array of ERC20s this pool will accept",decimals:"the decimals to use for each pooled token, eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS",lpTokenName:"the long-form name of the token to be deployed",lpTokenSymbol:"the short symbol for the token to be deployed",lpTokenTargetAddress:"the address of an existing LPToken contract to use as a target"},notice:"Initializes this Swap contract with the given parameters. This will also clone a LPToken contract that represents users' LP positions. The owner of LPToken will be this contract - which means only this contract is allowed to mint/burn tokens."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pause the contract. Revert if already paused."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"rampA(uint256,uint256)":{inputs:[{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"futureTime",type:"uint256"}],name:"rampA",outputs:[],stateMutability:"nonpayable",type:"function",params:{futureA:"the new A to ramp towards",futureTime:"timestamp when the new A should be reached"},notice:"Start ramping up or down A parameter towards given futureA and futureTime Checks if the change is too rapid, and commits the new A value only when it falls under the limit range."},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function",details:"Liquidity can always be removed, even when the pool is paused.",params:{amount:"the amount of LP tokens to burn",deadline:"latest timestamp to accept this transaction",minAmounts:"the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation"},returns:{_0:"amounts of tokens user received"},notice:"Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"how much of each token to withdraw",deadline:"latest timestamp to accept this transaction",maxBurnAmount:"the max LP token provider is willing to pay to remove liquidity. Useful as a front-running mitigation."},returns:{_0:"amount of LP tokens burned"},notice:"Remove liquidity from the pool, weighted differently than the pool's current balances. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",minAmount:"the minimum amount to withdraw, otherwise revert",tokenAmount:"the amount of the token you want to receive",tokenIndex:"the index of the token you want to receive"},returns:{_0:"amount of chosen token user received"},notice:"Remove liquidity from the pool all in one token. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setAdminFee(uint256)":{inputs:[{internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"setAdminFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{newAdminFee:"new admin fee to be applied on future transactions"},notice:"Update the admin fee. Admin fee takes portion of the swap fee."},"setRewardReceiver(address)":{inputs:[{internalType:"address",name:"_reward_receiver",type:"address"}],name:"setRewardReceiver",outputs:[],stateMutability:"nonpayable",type:"function"},"setSwapFee(uint256)":{inputs:[{internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"setSwapFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{newSwapFee:"new swap fee to be applied on future transactions"},notice:"Update the swap fee to be applied on swaps"},"stopRampA()":{inputs:[],name:"stopRampA",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Stop ramping A immediately. Reverts if ramp A is already stopped."},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",dx:"the amount of tokens the user wants to swap from",minDy:"the min amount the user would like to receive, or revert.",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Swap two tokens using this pool"},"swapStorage()":{inputs:[],name:"swapStorage",outputs:[{internalType:"uint256",name:"initialA",type:"uint256"},{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"initialATime",type:"uint256"},{internalType:"uint256",name:"futureATime",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"contract LPToken",name:"lpToken",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Unpause the contract. Revert if already unpaused."},"withdrawAdminFees()":{inputs:[],name:"withdrawAdminFees",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Withdraw all admin fees to the contract owner"}}},"contracts/amm/AaveSwapWrapper.sol:AaveSwapWrapper":{source:"contracts/amm/AaveSwapWrapper.sol",name:"AaveSwapWrapper",title:"AaveSwapWrapper",notice:"A wrapper contract for interacting with aTokens",constructor:{inputs:[{internalType:"contract Swap",name:"swap",type:"address"},{internalType:"contract IERC20[]",name:"underlyingTokens",type:"address[]"},{internalType:"address",name:"lendingPool",type:"address"},{internalType:"address",name:"owner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"LENDING_POOL()":{inputs:[],name:"LENDING_POOL",outputs:[{internalType:"contract ILendingPool",name:"",type:"address"}],stateMutability:"view",type:"function"},"LP_TOKEN()":{inputs:[],name:"LP_TOKEN",outputs:[{internalType:"contract LPToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"OWNER()":{inputs:[],name:"OWNER",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"POOLED_TOKENS(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"POOLED_TOKENS",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"SWAP()":{inputs:[],name:"SWAP",outputs:[{internalType:"contract Swap",name:"",type:"address"}],stateMutability:"view",type:"function"},"UNDERLYING_TOKENS(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"UNDERLYING_TOKENS",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"the amounts of each token to add, in their native precision",deadline:"latest timestamp to accept this transaction",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation"},returns:{_0:"amount of LP token user minted and received"},notice:"Add liquidity to the pool with the given amounts of tokens."},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{amount:"the amount of LP tokens that would be burned on withdrawal"},returns:{_0:"array of token balances that the user will receive"},notice:"A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function",params:{tokenAmount:"the amount of LP token to burn",tokenIndex:"index of which token will be withdrawn"},returns:{availableTokenAmount:"calculated amount of underlying token available to withdraw"},notice:"Calculate the amount of underlying token available to withdraw when withdrawing via only single token"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This shouldn't be used outside frontends for user estimates.",params:{amounts:"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.",deposit:"whether this is a deposit or a withdrawal"},returns:{_0:"token amount the user will receive"},notice:'A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running'},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"address of the token at given index"},notice:"Return address of the pooled token at given index. Reverts if tokenIndex is out of range."},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function",details:"Liquidity can always be removed, even when the pool is paused. Caller will receive ETH instead of WETH9.",params:{amount:"the amount of LP tokens to burn",deadline:"latest timestamp to accept this transaction",minAmounts:"the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation"},returns:{_0:"amounts of tokens user received"},notice:"Burn LP tokens to remove liquidity from the pool."},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Caller will receive ETH instead of WETH9.",params:{deadline:"latest timestamp to accept this transaction",minAmount:"the minimum amount to withdraw, otherwise revert",tokenAmount:"the amount of the token you want to receive",tokenIndex:"the index of the token you want to receive"},returns:{_0:"amount of chosen token user received"},notice:"Remove liquidity from the pool all in one token."},"rescue()":{inputs:[],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Rescues any of the ETH, the pooled tokens, or the LPToken that may be stuck in this contract. Only the OWNER can call this function."},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",dx:"the amount of tokens the user wants to swap from",minDy:"the min amount the user would like to receive, or revert.",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Swap two tokens using the underlying pool. If tokenIndexFrom represents WETH9 in the pool, the caller must set msg.value equal to dx. If the user is swapping to WETH9 in the pool, the user will receive ETH instead."}}},"contracts/amm/AaveSwapWrapper.sol:ILendingPool":{source:"contracts/amm/AaveSwapWrapper.sol",name:"ILendingPool",methods:{"deposit(address,uint256,address,uint16)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"onBehalfOf",type:"address"},{internalType:"uint16",name:"referralCode",type:"uint16"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",details:"Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC",params:{amount:"The amount to be deposited",asset:"The address of the underlying asset to deposit",onBehalfOf:"The address that will receive the aTokens, same as msg.sender if the user   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens   is a different wallet",referralCode:"Code used to register the integrator originating the operation, for potential rewards.   0 if the action is executed directly by the user, without any middle-man*"}},"withdraw(address,uint256,address)":{inputs:[{internalType:"address",name:"asset",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"withdraw",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC",params:{amount:"The underlying amount to be withdrawn   - Send the value type(uint256).max in order to withdraw the whole aToken balance",asset:"The address of the underlying asset to withdraw",to:"Address that will receive the underlying, same as msg.sender if the user   wants to receive it on his own wallet, or a different address if the beneficiary is a   different wallet"},returns:{_0:"The final amount withdrawn*"}}}},"contracts/amm/AmplificationUtils.sol:AmplificationUtils":{source:"contracts/amm/AmplificationUtils.sol",name:"AmplificationUtils",title:"AmplificationUtils library",notice:"A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct. This library assumes the struct is fully validated.",events:{"RampA(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"initialTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"futureTime",type:"uint256"}],name:"RampA",type:"event"},"StopRampA(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"currentA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"time",type:"uint256"}],name:"StopRampA",type:"event"}},methods:{"A_PRECISION()":{inputs:[],name:"A_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_A()":{inputs:[],name:"MAX_A",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/amm/LPToken.sol:LPToken":{source:"contracts/amm/LPToken.sol",name:"LPToken",title:"Liquidity Provider Token",details:"Only Swap contracts should initialize and own LPToken contracts.",notice:"This token is an ERC20 detailed token with added capability to be minted by the owner. It is used to represent user's shares when providing liquidity to swap contracts.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from the caller. See {ERC20-_burn}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"}],name:"initialize",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"The caller of this function will become the owner. A Swap contract should call this in its initializer function.",params:{name:"name of this token",symbol:"symbol of this token"},notice:"Initializes this LPToken contract with the given name and symbol"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"only owner can call this mint function",params:{amount:"amount of tokens to mint",recipient:"address of account to receive the tokens"},notice:"Mints the given amount of LPToken to the recipient."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/amm/MathUtils.sol:MathUtils":{source:"contracts/amm/MathUtils.sol",name:"MathUtils",title:"MathUtils library",notice:"A library to be used in conjunction with SafeMath. Contains functions for calculating differences between two uint256."},"contracts/amm/OwnerPausableUpgradeable.sol:OwnerPausableUpgradeable":{source:"contracts/amm/OwnerPausableUpgradeable.sol",name:"OwnerPausableUpgradeable",title:"OwnerPausable",details:"Only methods using the provided modifiers will be paused.",notice:"An ownable contract allows the owner to pause and unpause the contract without a delay.",events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pause the contract. Revert if already paused."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Unpause the contract. Revert if already unpaused."}}},"contracts/amm/Swap.sol:Swap":{source:"contracts/amm/Swap.sol",name:"Swap",title:"Swap - A StableSwap implementation in solidity.",details:"Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's deployment size.",notice:"This contract is responsible for custody of closely pegged assets (eg. group of stablecoins) and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens in desired ratios for an exchange of the pool token that represents their share of the pool. Users can burn pool tokens and withdraw their share of token(s). Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets distributed to the LPs. In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which stops the ratio of the tokens in the pool from changing. Users can always withdraw their tokens via multi-asset withdraws.",events:{"AddLiquidity(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"AddLiquidity",type:"event"},"NewAdminFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"NewAdminFee",type:"event"},"NewSwapFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"NewSwapFee",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RampA(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"initialTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"futureTime",type:"uint256"}],name:"RampA",type:"event"},"RemoveLiquidity(address,uint256[],uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidity",type:"event"},"RemoveLiquidityImbalance(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidityImbalance",type:"event"},"RemoveLiquidityOne(address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256",name:"lpTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"},{indexed:!1,internalType:"uint256",name:"boughtId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"}],name:"RemoveLiquidityOne",type:"event"},"StopRampA(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"currentA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"time",type:"uint256"}],name:"StopRampA",type:"event"},"TokenSwap(address,uint256,uint256,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"buyer",type:"address"},{indexed:!1,internalType:"uint256",name:"tokensSold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"},{indexed:!1,internalType:"uint128",name:"soldId",type:"uint128"},{indexed:!1,internalType:"uint128",name:"boughtId",type:"uint128"}],name:"TokenSwap",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"the amounts of each token to add, in their native precision",deadline:"latest timestamp to accept this transaction",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation"},returns:{_0:"amount of LP token user minted and received"},notice:"Add liquidity to the pool with the given amounts of tokens"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{amount:"the amount of LP tokens that would be burned on withdrawal"},returns:{_0:"array of token balances that the user will receive"},notice:"A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function",params:{tokenAmount:"the amount of LP token to burn",tokenIndex:"index of which token will be withdrawn"},returns:{availableTokenAmount:"calculated amount of underlying token available to withdraw"},notice:"Calculate the amount of underlying token available to withdraw when withdrawing via only single token"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This shouldn't be used outside frontends for user estimates.",params:{amounts:"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.",deposit:"whether this is a deposit or a withdrawal"},returns:{_0:"token amount the user will receive"},notice:'A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running'},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See the StableSwap paper for details",returns:{_0:"A parameter"},notice:"Return A, the amplification coefficient * n * (n - 1)"},"getAPrecise()":{inputs:[],name:"getAPrecise",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See the StableSwap paper for details",returns:{_0:"A parameter in its raw precision form"},notice:"Return A in its raw precision form"},"getAdminBalance(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getAdminBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{index:"Index of the pooled token"},returns:{_0:"admin's token balance in the token's precision"},notice:"This function reads the accumulated amount of admin fees of the token with given index"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"address of the token at given index"},notice:"Return address of the pooled token at given index. Reverts if tokenIndex is out of range."},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"current balance of the pooled token at given index with token's native precision"},notice:"Return current balance of the pooled token at given index"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{tokenAddress:"address of the token"},returns:{_0:"the index of the given token address"},notice:"Return the index of the given token address. Reverts if no matching token is found."},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"the virtual price, scaled to the POOL_PRECISION_DECIMALS"},notice:"Get the virtual price, to help calculate profit"},"initialize(address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"contract IERC20[]",name:"_pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"_a",type:"uint256"},{internalType:"uint256",name:"_fee",type:"uint256"},{internalType:"uint256",name:"_adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_a:"the amplification coefficient * n * (n - 1). See the StableSwap paper for details",_adminFee:"default adminFee to be initialized with",_fee:"default swap fee to be initialized with",_pooledTokens:"an array of ERC20s this pool will accept",decimals:"the decimals to use for each pooled token, eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS",lpTokenName:"the long-form name of the token to be deployed",lpTokenSymbol:"the short symbol for the token to be deployed",lpTokenTargetAddress:"the address of an existing LPToken contract to use as a target"},notice:"Initializes this Swap contract with the given parameters. This will also clone a LPToken contract that represents users' LP positions. The owner of LPToken will be this contract - which means only this contract is allowed to mint/burn tokens."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pause the contract. Revert if already paused."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"rampA(uint256,uint256)":{inputs:[{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"futureTime",type:"uint256"}],name:"rampA",outputs:[],stateMutability:"nonpayable",type:"function",params:{futureA:"the new A to ramp towards",futureTime:"timestamp when the new A should be reached"},notice:"Start ramping up or down A parameter towards given futureA and futureTime Checks if the change is too rapid, and commits the new A value only when it falls under the limit range."},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function",details:"Liquidity can always be removed, even when the pool is paused.",params:{amount:"the amount of LP tokens to burn",deadline:"latest timestamp to accept this transaction",minAmounts:"the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation"},returns:{_0:"amounts of tokens user received"},notice:"Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"how much of each token to withdraw",deadline:"latest timestamp to accept this transaction",maxBurnAmount:"the max LP token provider is willing to pay to remove liquidity. Useful as a front-running mitigation."},returns:{_0:"amount of LP tokens burned"},notice:"Remove liquidity from the pool, weighted differently than the pool's current balances. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",minAmount:"the minimum amount to withdraw, otherwise revert",tokenAmount:"the amount of the token you want to receive",tokenIndex:"the index of the token you want to receive"},returns:{_0:"amount of chosen token user received"},notice:"Remove liquidity from the pool all in one token. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setAdminFee(uint256)":{inputs:[{internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"setAdminFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{newAdminFee:"new admin fee to be applied on future transactions"},notice:"Update the admin fee. Admin fee takes portion of the swap fee."},"setSwapFee(uint256)":{inputs:[{internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"setSwapFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{newSwapFee:"new swap fee to be applied on future transactions"},notice:"Update the swap fee to be applied on swaps"},"stopRampA()":{inputs:[],name:"stopRampA",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Stop ramping A immediately. Reverts if ramp A is already stopped."},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",dx:"the amount of tokens the user wants to swap from",minDy:"the min amount the user would like to receive, or revert.",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Swap two tokens using this pool"},"swapStorage()":{inputs:[],name:"swapStorage",outputs:[{internalType:"uint256",name:"initialA",type:"uint256"},{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"initialATime",type:"uint256"},{internalType:"uint256",name:"futureATime",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"contract LPToken",name:"lpToken",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Unpause the contract. Revert if already unpaused."},"withdrawAdminFees()":{inputs:[],name:"withdrawAdminFees",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Withdraw all admin fees to the contract owner"}}},"contracts/amm/SwapDeployer.sol:SwapDeployer":{source:"contracts/amm/SwapDeployer.sol",name:"SwapDeployer",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"NewSwapPool(address,address,address[])":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"deployer",type:"address"},{indexed:!1,internalType:"address",name:"swapAddress",type:"address"},{indexed:!1,internalType:"contract IERC20[]",name:"pooledTokens",type:"address[]"}],name:"NewSwapPool",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"deploy(address,address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"swapAddress",type:"address"},{internalType:"contract IERC20[]",name:"_pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"_a",type:"uint256"},{internalType:"uint256",name:"_fee",type:"uint256"},{internalType:"uint256",name:"_adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"deploy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/amm/SwapEthWrapper.sol:SwapEthWrapper":{source:"contracts/amm/SwapEthWrapper.sol",name:"SwapEthWrapper",title:"SwapEthWrapper",author:"Jongseung Lim (@weeb_mcgee)",notice:"A wrapper contract for Swap contracts that have WETH as one of the pooled tokens.",constructor:{inputs:[{internalType:"address payable",name:"wethAddress",type:"address"},{internalType:"contract Swap",name:"swap",type:"address"},{internalType:"address",name:"owner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},methods:{"LP_TOKEN()":{inputs:[],name:"LP_TOKEN",outputs:[{internalType:"contract LPToken",name:"",type:"address"}],stateMutability:"view",type:"function"},"OWNER()":{inputs:[],name:"OWNER",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"SWAP()":{inputs:[],name:"SWAP",outputs:[{internalType:"contract Swap",name:"",type:"address"}],stateMutability:"view",type:"function"},"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"WETH_INDEX()":{inputs:[],name:"WETH_INDEX",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function",details:"The msg.value of this call should match the value in amounts array in position of WETH9.",params:{amounts:"the amounts of each token to add, in their native precision",deadline:"latest timestamp to accept this transaction",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation"},returns:{_0:"amount of LP token user minted and received"},notice:"Add liquidity to the pool with the given amounts of tokens."},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{amount:"the amount of LP tokens that would be burned on withdrawal"},returns:{_0:"array of token balances that the user will receive"},notice:"A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function",params:{tokenAmount:"the amount of LP token to burn",tokenIndex:"index of which token will be withdrawn"},returns:{availableTokenAmount:"calculated amount of underlying token available to withdraw"},notice:"Calculate the amount of underlying token available to withdraw when withdrawing via only single token"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This shouldn't be used outside frontends for user estimates.",params:{amounts:"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.",deposit:"whether this is a deposit or a withdrawal"},returns:{_0:"token amount the user will receive"},notice:'A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running'},"pooledTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pooledTokens",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function",details:"Liquidity can always be removed, even when the pool is paused. Caller will receive ETH instead of WETH9.",params:{amount:"the amount of LP tokens to burn",deadline:"latest timestamp to accept this transaction",minAmounts:"the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation"},returns:{_0:"amounts of tokens user received"},notice:"Burn LP tokens to remove liquidity from the pool."},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Caller will receive ETH instead of WETH9.",params:{amounts:"how much of each token to withdraw",deadline:"latest timestamp to accept this transaction",maxBurnAmount:"the max LP token provider is willing to pay to remove liquidity. Useful as a front-running mitigation."},returns:{_0:"amount of LP tokens burned"},notice:"Remove liquidity from the pool, weighted differently than the pool's current balances."},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Caller will receive ETH instead of WETH9.",params:{deadline:"latest timestamp to accept this transaction",minAmount:"the minimum amount to withdraw, otherwise revert",tokenAmount:"the amount of the token you want to receive",tokenIndex:"the index of the token you want to receive"},returns:{_0:"amount of chosen token user received"},notice:"Remove liquidity from the pool all in one token."},"rescue()":{inputs:[],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Rescues any of the ETH, the pooled tokens, or the LPToken that may be stuck in this contract. Only the OWNER can call this function."},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function",params:{deadline:"latest timestamp to accept this transaction",dx:"the amount of tokens the user wants to swap from",minDy:"the min amount the user would like to receive, or revert.",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Swap two tokens using the underlying pool. If tokenIndexFrom represents WETH9 in the pool, the caller must set msg.value equal to dx. If the user is swapping to WETH9 in the pool, the user will receive ETH instead."}}},"contracts/amm/SwapFlashLoan.sol:SwapFlashLoan":{source:"contracts/amm/SwapFlashLoan.sol",name:"SwapFlashLoan",title:"Swap - A StableSwap implementation in solidity.",details:"Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's deployment size.",notice:"This contract is responsible for custody of closely pegged assets (eg. group of stablecoins) and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens in desired ratios for an exchange of the pool token that represents their share of the pool. Users can burn pool tokens and withdraw their share of token(s). Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets distributed to the LPs. In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which stops the ratio of the tokens in the pool from changing. Users can always withdraw their tokens via multi-asset withdraws.",events:{"AddLiquidity(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"AddLiquidity",type:"event"},"FlashLoan(address,uint8,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"receiver",type:"address"},{indexed:!1,internalType:"uint8",name:"tokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"FlashLoan",type:"event"},"NewAdminFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"NewAdminFee",type:"event"},"NewSwapFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"NewSwapFee",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RampA(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"initialTime",type:"uint256"},{indexed:!1,internalType:"uint256",name:"futureTime",type:"uint256"}],name:"RampA",type:"event"},"RemoveLiquidity(address,uint256[],uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidity",type:"event"},"RemoveLiquidityImbalance(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidityImbalance",type:"event"},"RemoveLiquidityOne(address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256",name:"lpTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"},{indexed:!1,internalType:"uint256",name:"boughtId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"}],name:"RemoveLiquidityOne",type:"event"},"StopRampA(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"currentA",type:"uint256"},{indexed:!1,internalType:"uint256",name:"time",type:"uint256"}],name:"StopRampA",type:"event"},"TokenSwap(address,uint256,uint256,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"buyer",type:"address"},{indexed:!1,internalType:"uint256",name:"tokensSold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"},{indexed:!1,internalType:"uint128",name:"soldId",type:"uint128"},{indexed:!1,internalType:"uint128",name:"boughtId",type:"uint128"}],name:"TokenSwap",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"MAX_BPS()":{inputs:[],name:"MAX_BPS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"the amounts of each token to add, in their native precision",deadline:"latest timestamp to accept this transaction",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation"},returns:{_0:"amount of LP token user minted and received"},notice:"Add liquidity to the pool with the given amounts of tokens"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",params:{amount:"the amount of LP tokens that would be burned on withdrawal"},returns:{_0:"array of token balances that the user will receive"},notice:"A simple method to calculate amount of each underlying tokens that is returned upon burning given amount of LP tokens"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function",params:{tokenAmount:"the amount of LP token to burn",tokenIndex:"index of which token will be withdrawn"},returns:{availableTokenAmount:"calculated amount of underlying token available to withdraw"},notice:"Calculate the amount of underlying token available to withdraw when withdrawing via only single token"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This shouldn't be used outside frontends for user estimates.",params:{amounts:"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision. If a token charges a fee on transfers, use the amount that gets transferred after the fee.",deposit:"whether this is a deposit or a withdrawal"},returns:{_0:"token amount the user will receive"},notice:'A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running'},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"receiver",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"params",type:"bytes"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"the total amount to borrow in this transaction",params:"optional data to pass along to the callback function",receiver:"the address of the receiver of the token. This address must implement the IFlashLoanReceiver interface and the callback function `executeOperation`.",token:"the protocol fee in bps to be applied on the total flash loan fee"},notice:"Borrow the specified token from this pool for this transaction only. This function will call `IFlashLoanReceiver(receiver).executeOperation` and the `receiver` must return the full amount of the token and the associated fee by the end of the callback transaction. If the conditions are not met, this call is reverted."},"flashLoanFeeBPS()":{inputs:[],name:"flashLoanFeeBPS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See the StableSwap paper for details",returns:{_0:"A parameter"},notice:"Return A, the amplification coefficient * n * (n - 1)"},"getAPrecise()":{inputs:[],name:"getAPrecise",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See the StableSwap paper for details",returns:{_0:"A parameter in its raw precision form"},notice:"Return A in its raw precision form"},"getAdminBalance(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getAdminBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{index:"Index of the pooled token"},returns:{_0:"admin's token balance in the token's precision"},notice:"This function reads the accumulated amount of admin fees of the token with given index"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"address of the token at given index"},notice:"Return address of the pooled token at given index. Reverts if tokenIndex is out of range."},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"current balance of the pooled token at given index with token's native precision"},notice:"Return current balance of the pooled token at given index"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",params:{tokenAddress:"address of the token"},returns:{_0:"the index of the given token address"},notice:"Return the index of the given token address. Reverts if no matching token is found."},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"the virtual price, scaled to the POOL_PRECISION_DECIMALS"},notice:"Get the virtual price, to help calculate profit"},"initialize(address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"contract IERC20[]",name:"_pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"_a",type:"uint256"},{internalType:"uint256",name:"_fee",type:"uint256"},{internalType:"uint256",name:"_adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_a:"the amplification coefficient * n * (n - 1). See the StableSwap paper for details",_adminFee:"default adminFee to be initialized with",_fee:"default swap fee to be initialized with",_pooledTokens:"an array of ERC20s this pool will accept",decimals:"the decimals to use for each pooled token, eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS",lpTokenName:"the long-form name of the token to be deployed",lpTokenSymbol:"the short symbol for the token to be deployed",lpTokenTargetAddress:"the address of an existing LPToken contract to use as a target"},notice:"Initializes this Swap contract with the given parameters. This will also clone a LPToken contract that represents users' LP positions. The owner of LPToken will be this contract - which means only this contract is allowed to mint/burn tokens."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pause the contract. Revert if already paused."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"protocolFeeShareBPS()":{inputs:[],name:"protocolFeeShareBPS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"rampA(uint256,uint256)":{inputs:[{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"futureTime",type:"uint256"}],name:"rampA",outputs:[],stateMutability:"nonpayable",type:"function",params:{futureA:"the new A to ramp towards",futureTime:"timestamp when the new A should be reached"},notice:"Start ramping up or down A parameter towards given futureA and futureTime Checks if the change is too rapid, and commits the new A value only when it falls under the limit range."},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function",details:"Liquidity can always be removed, even when the pool is paused.",params:{amount:"the amount of LP tokens to burn",deadline:"latest timestamp to accept this transaction",minAmounts:"the minimum amounts of each token in the pool        acceptable for this burn. Useful as a front-running mitigation"},returns:{_0:"amounts of tokens user received"},notice:"Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amounts:"how much of each token to withdraw",deadline:"latest timestamp to accept this transaction",maxBurnAmount:"the max LP token provider is willing to pay to remove liquidity. Useful as a front-running mitigation."},returns:{_0:"amount of LP tokens burned"},notice:"Remove liquidity from the pool, weighted differently than the pool's current balances. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",minAmount:"the minimum amount to withdraw, otherwise revert",tokenAmount:"the amount of the token you want to receive",tokenIndex:"the index of the token you want to receive"},returns:{_0:"amount of chosen token user received"},notice:"Remove liquidity from the pool all in one token. Withdraw fee that decays linearly over period of 4 weeks since last deposit will apply."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setAdminFee(uint256)":{inputs:[{internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"setAdminFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{newAdminFee:"new admin fee to be applied on future transactions"},notice:"Update the admin fee. Admin fee takes portion of the swap fee."},"setFlashLoanFees(uint256,uint256)":{inputs:[{internalType:"uint256",name:"newFlashLoanFeeBPS",type:"uint256"},{internalType:"uint256",name:"newProtocolFeeShareBPS",type:"uint256"}],name:"setFlashLoanFees",outputs:[],stateMutability:"nonpayable",type:"function",params:{newFlashLoanFeeBPS:"the total fee in bps to be applied on future flash loans",newProtocolFeeShareBPS:"the protocol fee in bps to be applied on the total flash loan fee"},notice:"Updates the flash loan fee parameters. This function can only be called by the owner."},"setSwapFee(uint256)":{inputs:[{internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"setSwapFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{newSwapFee:"new swap fee to be applied on future transactions"},notice:"Update the swap fee to be applied on swaps"},"stopRampA()":{inputs:[],name:"stopRampA",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Stop ramping A immediately. Reverts if ramp A is already stopped."},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",dx:"the amount of tokens the user wants to swap from",minDy:"the min amount the user would like to receive, or revert.",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Swap two tokens using this pool"},"swapStorage()":{inputs:[],name:"swapStorage",outputs:[{internalType:"uint256",name:"initialA",type:"uint256"},{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"initialATime",type:"uint256"},{internalType:"uint256",name:"futureATime",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"contract LPToken",name:"lpToken",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Unpause the contract. Revert if already unpaused."},"withdrawAdminFees()":{inputs:[],name:"withdrawAdminFees",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Withdraw all admin fees to the contract owner"}}},"contracts/amm/SwapUtils.sol:SwapUtils":{source:"contracts/amm/SwapUtils.sol",name:"SwapUtils",title:"SwapUtils library",details:"Contracts relying on this library must initialize SwapUtils.Swap struct then use this library for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins. Admin functions should be protected within contracts using this library.",notice:"A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.",events:{"AddLiquidity(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"AddLiquidity",type:"event"},"NewAdminFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newAdminFee",type:"uint256"}],name:"NewAdminFee",type:"event"},"NewSwapFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"newSwapFee",type:"uint256"}],name:"NewSwapFee",type:"event"},"RemoveLiquidity(address,uint256[],uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidity",type:"event"},"RemoveLiquidityImbalance(address,uint256[],uint256[],uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256[]",name:"tokenAmounts",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"fees",type:"uint256[]"},{indexed:!1,internalType:"uint256",name:"invariant",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"}],name:"RemoveLiquidityImbalance",type:"event"},"RemoveLiquidityOne(address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"provider",type:"address"},{indexed:!1,internalType:"uint256",name:"lpTokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"lpTokenSupply",type:"uint256"},{indexed:!1,internalType:"uint256",name:"boughtId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"}],name:"RemoveLiquidityOne",type:"event"},"TokenSwap(address,uint256,uint256,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"buyer",type:"address"},{indexed:!1,internalType:"uint256",name:"tokensSold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"tokensBought",type:"uint256"},{indexed:!1,internalType:"uint128",name:"soldId",type:"uint128"},{indexed:!1,internalType:"uint128",name:"boughtId",type:"uint128"}],name:"TokenSwap",type:"event"}},methods:{"MAX_ADMIN_FEE()":{inputs:[],name:"MAX_ADMIN_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_SWAP_FEE()":{inputs:[],name:"MAX_SWAP_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"POOL_PRECISION_DECIMALS()":{inputs:[],name:"POOL_PRECISION_DECIMALS",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"}}},"contracts/amm/helper/BaseSwapDeposit.sol:BaseSwapDeposit":{source:"contracts/amm/helper/BaseSwapDeposit.sol",name:"BaseSwapDeposit",constructor:{inputs:[{internalType:"contract ISwap",name:"_baseSwap",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"baseSwap()":{inputs:[],name:"baseSwap",outputs:[{internalType:"contract ISwap",name:"",type:"address"}],stateMutability:"view",type:"function"},"baseTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"baseTokens",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"getToken(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",params:{index:"the index of the token"},returns:{_0:"address of the token at given index"},notice:"Returns the address of the pooled token at given index. Reverts if tokenIndex is out of range."},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{deadline:"latest timestamp to accept this transaction",dx:"the amount of tokens the user wants to swap from",minDy:"the min amount the user would like to receive, or revert.",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Swap two underlying tokens using the meta pool and the base pool"}}},"contracts/amm/helper/FlashLoanBorrowerExample.sol:FlashLoanBorrowerExample":{source:"contracts/amm/helper/FlashLoanBorrowerExample.sol",name:"FlashLoanBorrowerExample",methods:{"executeOperation(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes",name:"params",type:"bytes"}],name:"executeOperation",outputs:[],stateMutability:"nonpayable",type:"function"},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"contract ISwapFlashLoan",name:"swap",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"params",type:"bytes"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/helper/GenericERC20.sol:GenericERC20":{source:"contracts/amm/helper/GenericERC20.sol",name:"GenericERC20",title:"Generic ERC20 token",notice:"This contract simulates a generic ERC20 token that is mintable and burnable.",constructor:{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"uint8",name:"decimals_",type:"uint8"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"only owner can call this mint function",params:{amount:"amount of tokens to mint",recipient:"address of account to receive the tokens"},notice:"Mints given amount of tokens to recipient"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/amm/helper/Multicall2.sol:Multicall2":{source:"contracts/amm/helper/Multicall2.sol",name:"Multicall2",title:"Multicall2 - Aggregate results from multiple read-only function calls",author:"Michael Elliot <mike@makerdao.com>Joshua Levine <joshua@makerdao.com>Nick Johnson <arachnid@notdot.net>",methods:{"aggregate((address,bytes)[])":{inputs:[{components:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"callData",type:"bytes"}],internalType:"struct Multicall2.Call[]",name:"calls",type:"tuple[]"}],name:"aggregate",outputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"bytes[]",name:"returnData",type:"bytes[]"}],stateMutability:"nonpayable",type:"function"},"blockAndAggregate((address,bytes)[])":{inputs:[{components:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"callData",type:"bytes"}],internalType:"struct Multicall2.Call[]",name:"calls",type:"tuple[]"}],name:"blockAndAggregate",outputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"bytes32",name:"blockHash",type:"bytes32"},{components:[{internalType:"bool",name:"success",type:"bool"},{internalType:"bytes",name:"returnData",type:"bytes"}],internalType:"struct Multicall2.Result[]",name:"returnData",type:"tuple[]"}],stateMutability:"nonpayable",type:"function"},"getBlockHash(uint256)":{inputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"}],name:"getBlockHash",outputs:[{internalType:"bytes32",name:"blockHash",type:"bytes32"}],stateMutability:"view",type:"function"},"getBlockNumber()":{inputs:[],name:"getBlockNumber",outputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"}],stateMutability:"view",type:"function"},"getCurrentBlockCoinbase()":{inputs:[],name:"getCurrentBlockCoinbase",outputs:[{internalType:"address",name:"coinbase",type:"address"}],stateMutability:"view",type:"function"},"getCurrentBlockDifficulty()":{inputs:[],name:"getCurrentBlockDifficulty",outputs:[{internalType:"uint256",name:"difficulty",type:"uint256"}],stateMutability:"view",type:"function"},"getCurrentBlockGasLimit()":{inputs:[],name:"getCurrentBlockGasLimit",outputs:[{internalType:"uint256",name:"gaslimit",type:"uint256"}],stateMutability:"view",type:"function"},"getCurrentBlockTimestamp()":{inputs:[],name:"getCurrentBlockTimestamp",outputs:[{internalType:"uint256",name:"timestamp",type:"uint256"}],stateMutability:"view",type:"function"},"getEthBalance(address)":{inputs:[{internalType:"address",name:"addr",type:"address"}],name:"getEthBalance",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function"},"getLastBlockHash()":{inputs:[],name:"getLastBlockHash",outputs:[{internalType:"bytes32",name:"blockHash",type:"bytes32"}],stateMutability:"view",type:"function"},"tryAggregate(bool,(address,bytes)[])":{inputs:[{internalType:"bool",name:"requireSuccess",type:"bool"},{components:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"callData",type:"bytes"}],internalType:"struct Multicall2.Call[]",name:"calls",type:"tuple[]"}],name:"tryAggregate",outputs:[{components:[{internalType:"bool",name:"success",type:"bool"},{internalType:"bytes",name:"returnData",type:"bytes"}],internalType:"struct Multicall2.Result[]",name:"returnData",type:"tuple[]"}],stateMutability:"nonpayable",type:"function"},"tryBlockAndAggregate(bool,(address,bytes)[])":{inputs:[{internalType:"bool",name:"requireSuccess",type:"bool"},{components:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"callData",type:"bytes"}],internalType:"struct Multicall2.Call[]",name:"calls",type:"tuple[]"}],name:"tryBlockAndAggregate",outputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"bytes32",name:"blockHash",type:"bytes32"},{components:[{internalType:"bool",name:"success",type:"bool"},{internalType:"bytes",name:"returnData",type:"bytes"}],internalType:"struct Multicall2.Result[]",name:"returnData",type:"tuple[]"}],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/helper/test/TestMathUtils.sol:TestMathUtils":{source:"contracts/amm/helper/test/TestMathUtils.sol",name:"TestMathUtils",methods:{"difference(uint256,uint256)":{inputs:[{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"b",type:"uint256"}],name:"difference",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},"within1(uint256,uint256)":{inputs:[{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"b",type:"uint256"}],name:"within1",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"pure",type:"function"}}},"contracts/amm/helper/test/TestSwapReturnValues.sol:TestSwapReturnValues":{source:"contracts/amm/helper/test/TestSwapReturnValues.sol",name:"TestSwapReturnValues",constructor:{inputs:[{internalType:"contract ISwap",name:"swapContract",type:"address"},{internalType:"contract IERC20",name:"lpTokenContract",type:"address"},{internalType:"uint8",name:"numOfTokens",type:"uint8"}],stateMutability:"nonpayable",type:"constructor"},methods:{"MAX_INT()":{inputs:[],name:"MAX_INT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"lpToken()":{inputs:[],name:"lpToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"n()":{inputs:[],name:"n",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"swap()":{inputs:[],name:"swap",outputs:[{internalType:"contract ISwap",name:"",type:"address"}],stateMutability:"view",type:"function"},"test_addLiquidity(uint256[],uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"}],name:"test_addLiquidity",outputs:[],stateMutability:"nonpayable",type:"function"},"test_removeLiquidity(uint256,uint256[])":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"}],name:"test_removeLiquidity",outputs:[],stateMutability:"nonpayable",type:"function"},"test_removeLiquidityImbalance(uint256[],uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"}],name:"test_removeLiquidityImbalance",outputs:[],stateMutability:"nonpayable",type:"function"},"test_removeLiquidityOneToken(uint256,uint8,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"}],name:"test_removeLiquidityOneToken",outputs:[],stateMutability:"nonpayable",type:"function"},"test_swap(uint8,uint8,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"}],name:"test_swap",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/interfaces/IFlashLoanReceiver.sol:IFlashLoanReceiver":{source:"contracts/amm/interfaces/IFlashLoanReceiver.sol",name:"IFlashLoanReceiver",title:"IFlashLoanReceiver interface",author:"Aave",details:"implement this interface to develop a flashloan-compatible flashLoanReceiver contract*",notice:"Interface for the Nerve fee IFlashLoanReceiver. Modified from Aave's IFlashLoanReceiver interface. https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/flashloan/interfaces/IFlashLoanReceiver.sol",methods:{"executeOperation(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes",name:"params",type:"bytes"}],name:"executeOperation",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/interfaces/IMetaSwap.sol:IMetaSwap":{source:"contracts/amm/interfaces/IMetaSwap.sol",name:"IMetaSwap",methods:{"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateSwapUnderlying(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwapUnderlying",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initializeMetaSwap(address[],uint8[],string,string,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"contract IERC20[]",name:"pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"},{internalType:"address",name:"baseSwap",type:"address"}],name:"initializeMetaSwap",outputs:[],stateMutability:"nonpayable",type:"function"},"isGuarded()":{inputs:[],name:"isGuarded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swapStorage()":{inputs:[],name:"swapStorage",outputs:[{internalType:"uint256",name:"initialA",type:"uint256"},{internalType:"uint256",name:"futureA",type:"uint256"},{internalType:"uint256",name:"initialATime",type:"uint256"},{internalType:"uint256",name:"futureATime",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"address",name:"lpToken",type:"address"}],stateMutability:"view",type:"function"},"swapUnderlying(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapUnderlying",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/interfaces/IMetaSwapDeposit.sol:IMetaSwapDeposit":{source:"contracts/amm/interfaces/IMetaSwapDeposit.sol",name:"IMetaSwapDeposit",methods:{"initialize(address,address,address)":{inputs:[{internalType:"contract ISwap",name:"baseSwap_",type:"address"},{internalType:"contract IMetaSwap",name:"metaSwap_",type:"address"},{internalType:"contract IERC20",name:"metaLPToken_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/interfaces/ISwap.sol:ISwap":{source:"contracts/amm/interfaces/ISwap.sol",name:"ISwap",methods:{"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"contract IERC20[]",name:"pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/interfaces/ISwapFlashLoan.sol:ISwapFlashLoan":{source:"contracts/amm/interfaces/ISwapFlashLoan.sol",name:"ISwapFlashLoan",methods:{"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"flashLoan(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"receiver",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"params",type:"bytes"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function"},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"contract IERC20[]",name:"pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/amm/interfaces/IWETH9.sol:IWETH9":{source:"contracts/amm/interfaces/IWETH9.sol",name:"IWETH9",receive:{stateMutability:"payable",type:"receive"},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"guy",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"src",type:"address"},{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"wad",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/auxiliary/DummyWeth.sol:DummyWeth":{source:"contracts/auxiliary/DummyWeth.sol",name:"DummyWeth",fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"WETH()":{inputs:[],name:"WETH",outputs:[{internalType:"contract IWETH9",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rescue(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function"},"setWETHAddress(address)":{inputs:[{internalType:"address payable",name:"_weth",type:"address"}],name:"setWETHAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdrawToSelf(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"withdrawToSelf",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/auxiliary/DummyWeth.sol:IWETH9":{source:"contracts/auxiliary/DummyWeth.sol",name:"IWETH9",receive:{stateMutability:"payable",type:"receive"},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"guy",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"src",type:"address"},{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"wad",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/auxiliary/DummyWethProxy.sol:DummyWethProxy":{source:"contracts/auxiliary/DummyWethProxy.sol",name:"DummyWethProxy",fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"WETH()":{inputs:[],name:"WETH",outputs:[{internalType:"contract IWETH9",name:"",type:"address"}],stateMutability:"view",type:"function"},"initialize()":{inputs:[],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"rescue(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function"},"setWETHAddress(address)":{inputs:[{internalType:"address payable",name:"_weth",type:"address"}],name:"setWETHAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"withdrawToSelf(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"withdrawToSelf",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/auxiliary/DummyWethProxy.sol:IWETH9":{source:"contracts/auxiliary/DummyWethProxy.sol",name:"IWETH9",receive:{stateMutability:"payable",type:"receive"},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"guy",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"src",type:"address"},{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"wad",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/auxiliary/WETH9.sol:WETH9":{source:"contracts/auxiliary/WETH9.sol",name:"WETH9",fallback:{payable:!0,stateMutability:"payable",type:"fallback"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"src",type:"address"},{indexed:!0,name:"guy",type:"address"},{indexed:!1,name:"wad",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"src",type:"address"},{indexed:!0,name:"dst",type:"address"},{indexed:!1,name:"wad",type:"uint256"}],name:"Transfer",type:"event"},"Deposit(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"dst",type:"address"},{indexed:!1,name:"wad",type:"uint256"}],name:"Deposit",type:"event"},"Withdrawal(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,name:"src",type:"address"},{indexed:!1,name:"wad",type:"uint256"}],name:"Withdrawal",type:"event"}},methods:{"name()":{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},"approve(address,uint256)":{constant:!1,inputs:[{name:"guy",type:"address"},{name:"wad",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},"totalSupply()":{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"transferFrom(address,address,uint256)":{constant:!1,inputs:[{name:"src",type:"address"},{name:"dst",type:"address"},{name:"wad",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{constant:!1,inputs:[{name:"wad",type:"uint256"}],name:"withdraw",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},"decimals()":{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},"balanceOf(address)":{constant:!0,inputs:[{name:"",type:"address"}],name:"balanceOf",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},"symbol()":{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},"transfer(address,uint256)":{constant:!1,inputs:[{name:"dst",type:"address"},{name:"wad",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},"deposit()":{constant:!1,inputs:[],name:"deposit",outputs:[],payable:!0,stateMutability:"payable",type:"function"},"allowance(address,address)":{constant:!0,inputs:[{name:"",type:"address"},{name:"",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"}}},"contracts/bridge/BridgeConfig.sol:BridgeConfig":{source:"contracts/bridge/BridgeConfig.sol",name:"BridgeConfig",title:"BridgeConfig contract",notice:"This token is used for configuring different tokens on the bridge and mapping them across chains.*",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"BRIDGEMANAGER_ROLE()":{inputs:[],name:"BRIDGEMANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"calculateSwapFee(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This means the fee should be calculated based on the chain that the nodes emit a tx on",params:{amount:"in native token decimals",chainID:"destination chain ID to query the token config for",tokenAddress:"address of the destination token to query token config for"},returns:{_0:"Fee calculated in token decimals"},notice:"Calculates bridge swap fee based on the destination chain's token transfer."},"getAllTokenIDs()":{inputs:[],name:"getAllTokenIDs",outputs:[{internalType:"string[]",name:"result",type:"string[]"}],stateMutability:"view",type:"function",notice:"Returns a list of all existing token IDs converted to strings"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"getToken(string,uint256)":{inputs:[{internalType:"string",name:"tokenID",type:"string"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getToken",outputs:[{components:[{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],internalType:"struct BridgeConfig.Token",name:"token",type:"tuple"}],stateMutability:"view",type:"function",params:{chainID:"Chain ID of which token address + config to get",tokenID:"String input of the token ID for the token"},notice:"Returns the full token config struct"},"getToken(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getToken",outputs:[{components:[{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],internalType:"struct BridgeConfig.Token",name:"token",type:"tuple"}],stateMutability:"view",type:"function",params:{chainID:"Chain ID of which token to get config for",tokenAddress:"Matches the token ID by using a combo of address + chain ID"},notice:"Returns token config struct, given an address and chainID"},"getTokenID(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getTokenID",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",params:{chainID:"chainID of which to get token ID for",tokenAddress:"address of token to get ID for"},notice:"Returns the token ID (string) of the cross-chain token inputted"},"getUnderlyingToken(string)":{inputs:[{internalType:"string",name:"tokenID",type:"string"}],name:"getUnderlyingToken",outputs:[{components:[{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],internalType:"struct BridgeConfig.Token",name:"token",type:"tuple"}],stateMutability:"view",type:"function",params:{tokenID:"string token ID"},notice:"Returns which token is the underlying token to withdraw"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"hasUnderlyingToken(string)":{inputs:[{internalType:"string",name:"tokenID",type:"string"}],name:"hasUnderlyingToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{tokenID:"String to check if it is a withdraw/underlying token"},notice:"Returns true if the token has an underlying token -- meaning the token is deposited into the bridge"},"isTokenIDExist(string)":{inputs:[{internalType:"string",name:"tokenID",type:"string"}],name:"isTokenIDExist",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Public function returning if token ID exists given a string"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setTokenConfig(string,uint256,address,uint8,uint256,uint256,uint256,uint256,uint256,bool,bool)":{inputs:[{internalType:"string",name:"tokenID",type:"string"},{internalType:"uint256",name:"chainID",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],name:"setTokenConfig",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{chainID:"chain ID to use for the token config object",hasUnderlying:"bool which represents whether this is a global mint token or one to withdraw()",isUnderlying:"bool which represents if this token is the one to withdraw on the given chain",maxSwap:"maximum amount of token allowed to be transferred at once - in native token decimals",maxSwapFee:"max swap fee to be charged - in native token decimals",minSwap:"minimum amount of token needed to be transferred at once - in native token decimals",minSwapFee:"min swap fee to be charged - in native token decimals - especially useful for mainnet ETH",swapFee:"percent based swap fee -- 10e6 == 10bps",tokenAddress:"token address of the token on the given chain",tokenDecimals:"decimals of token",tokenID:"string ID to set the token config object form"},notice:"Main write function of this contract - Handles creating the struct and passing it to the internal logic function"}}},"contracts/bridge/BridgeConfigv2.sol:BridgeConfigV2":{source:"contracts/bridge/BridgeConfigv2.sol",name:"BridgeConfigV2",title:"BridgeConfigV2 contract",notice:"This token is used for configuring different tokens on the bridge and mapping them across chains. It wraps bridge config for data storage*",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"BRIDGECONFIG_V1()":{inputs:[],name:"BRIDGECONFIG_V1",outputs:[{internalType:"contract BridgeConfig",name:"",type:"address"}],stateMutability:"view",type:"function"},"BRIDGEMANAGER_ROLE()":{inputs:[],name:"BRIDGEMANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"POOLCONFIG_V1()":{inputs:[],name:"POOLCONFIG_V1",outputs:[{internalType:"contract PoolConfig",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateSwapFee(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateSwapFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This means the fee should be calculated based on the chain that the nodes emit a tx on",params:{amount:"in native token decimals",chainID:"destination chain ID to query the token config for",tokenAddress:"address of the destination token to query token config for"},returns:{_0:"Fee calculated in token decimals"},notice:"Calculates bridge swap fee based on the destination chain's token transfer."},"getAllTokenIDs()":{inputs:[],name:"getAllTokenIDs",outputs:[{internalType:"string[]",name:"result",type:"string[]"}],stateMutability:"view",type:"function",notice:"Returns a list of all existing token IDs converted to strings"},"getMaxGasPrice(uint256)":{inputs:[{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getMaxGasPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"gets the max gas price for a chain"},"getPoolConfig(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getPoolConfig",outputs:[{components:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"poolAddress",type:"address"},{internalType:"bool",name:"metaswap",type:"bool"}],internalType:"struct PoolConfig.Pool",name:"",type:"tuple"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"getToken(string,uint256)":{inputs:[{internalType:"string",name:"tokenID",type:"string"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getToken",outputs:[{components:[{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],internalType:"struct BridgeConfig.Token",name:"token",type:"tuple"}],stateMutability:"view",type:"function",params:{chainID:"Chain ID of which token address + config to get",tokenID:"String input of the token ID for the token"},notice:"Returns the full token config struct"},"getToken(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getToken",outputs:[{components:[{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],internalType:"struct BridgeConfig.Token",name:"token",type:"tuple"}],stateMutability:"view",type:"function",params:{chainID:"Chain ID of which token to get config for",tokenAddress:"Matches the token ID by using a combo of address + chain ID"},notice:"Returns token config struct, given an address and chainID"},"getTokenID(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getTokenID",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",params:{chainID:"chainID of which to get token ID for",tokenAddress:"address of token to get ID for"},notice:"Returns the token ID (string) of the cross-chain token inputted"},"getUnderlyingToken(string)":{inputs:[{internalType:"string",name:"tokenID",type:"string"}],name:"getUnderlyingToken",outputs:[{components:[{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint8",name:"tokenDecimals",type:"uint8"},{internalType:"uint256",name:"maxSwap",type:"uint256"},{internalType:"uint256",name:"minSwap",type:"uint256"},{internalType:"uint256",name:"swapFee",type:"uint256"},{internalType:"uint256",name:"maxSwapFee",type:"uint256"},{internalType:"uint256",name:"minSwapFee",type:"uint256"},{internalType:"bool",name:"hasUnderlying",type:"bool"},{internalType:"bool",name:"isUnderlying",type:"bool"}],internalType:"struct BridgeConfig.Token",name:"token",type:"tuple"}],stateMutability:"view",type:"function",params:{tokenID:"string token ID"},notice:"Returns which token is the underlying token to withdraw"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"hasUnderlyingToken(string)":{inputs:[{internalType:"string",name:"tokenID",type:"string"}],name:"hasUnderlyingToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{tokenID:"String to check if it is a withdraw/underlying token"},notice:"Returns true if the token has an underlying token -- meaning the token is deposited into the bridge"},"isTokenIDExist(string)":{inputs:[{internalType:"string",name:"tokenID",type:"string"}],name:"isTokenIDExist",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Public function returning if token ID exists given a string"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setBridgeConfig(address,address)":{inputs:[{internalType:"contract BridgeConfig",name:"bridgeconfig",type:"address"},{internalType:"contract PoolConfig",name:"poolconfig",type:"address"}],name:"setBridgeConfig",outputs:[],stateMutability:"nonpayable",type:"function"},"setMaxGasPrice(uint256,uint256)":{inputs:[{internalType:"uint256",name:"chainID",type:"uint256"},{internalType:"uint256",name:"maxPrice",type:"uint256"}],name:"setMaxGasPrice",outputs:[],stateMutability:"nonpayable",type:"function",notice:"sets the max gas price for a chain"}}},"contracts/bridge/ECDSAFactory.sol:ECDSAFactory":{source:"contracts/bridge/ECDSAFactory.sol",name:"ECDSAFactory",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"ECDSANodeGroupCreated(address,address[],address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"keepAddress",type:"address"},{indexed:!1,internalType:"address[]",name:"members",type:"address[]"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"honestThreshold",type:"uint256"}],name:"ECDSANodeGroupCreated",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"deploy(address,address,address[],uint256)":{inputs:[{internalType:"address",name:"nodeMgmtAddress",type:"address"},{internalType:"address",name:"owner",type:"address"},{internalType:"address[]",name:"members",type:"address[]"},{internalType:"uint256",name:"honestThreshold",type:"uint256"}],name:"deploy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",params:{honestThreshold:"Number of signers to process a transaction ",members:"Array of node group members addresses",nodeMgmtAddress:"address of the ECDSANodeManagement contract to initialize with",owner:"Owner of the  ECDSANodeManagement contract who can determine if the node group is closed or active"},returns:{_0:"Address of the newest node management contract created*"},notice:"Deploys a new node "},"getMembers()":{inputs:[],name:"getMembers",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",returns:{_0:"List of the keep members' addresses."},notice:"Returns members of the keep."},"latestNodeGroup()":{inputs:[],name:"latestNodeGroup",outputs:[{internalType:"address",name:"keepAddress",type:"address"},{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"honestThreshold",type:"uint256"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/bridge/ECDSANodeManagement.sol:ECDSANodeManagement":{source:"contracts/bridge/ECDSANodeManagement.sol",name:"ECDSANodeManagement",events:{"ConflictingPublicKeySubmitted(address,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"submittingMember",type:"address"},{indexed:!1,internalType:"bytes",name:"conflictingPublicKey",type:"bytes"}],name:"ConflictingPublicKeySubmitted",type:"event"},"KeepClosed()":{anonymous:!1,inputs:[],name:"KeepClosed",type:"event"},"KeepTerminated()":{anonymous:!1,inputs:[],name:"KeepTerminated",type:"event"},"PublicKeyPublished(bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bytes",name:"publicKey",type:"bytes"}],name:"PublicKeyPublished",type:"event"}},methods:{"closeKeep()":{inputs:[],name:"closeKeep",outputs:[],stateMutability:"nonpayable",type:"function",details:"The function can be called only by the owner of the keep and only if the keep has not been already closed.",notice:"Closes keep when owner decides that they no longer need it. Releases bonds to the keep members."},"getMembers()":{inputs:[],name:"getMembers",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",returns:{_0:"List of the keep members' addresses."},notice:"Returns members of the keep."},"getOpenedTimestamp()":{inputs:[],name:"getOpenedTimestamp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"Timestamp the keep was opened at."},notice:"Gets the timestamp the keep was opened at."},"getOwner()":{inputs:[],name:"getOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Address of the keep owner."},notice:"Gets the owner of the keep."},"getPublicKey()":{inputs:[],name:"getPublicKey",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function",returns:{_0:"Keep's ECDSA public key."},notice:"Returns keep's ECDSA public key."},"honestThreshold()":{inputs:[],name:"honestThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address,address[],uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address[]",name:"_members",type:"address[]"},{internalType:"uint256",name:"_honestThreshold",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"We use clone factory to create new keep. That is why this contract doesn't have a constructor. We provide keep parameters for each instance function after cloning instances from the master contract. Initialization must happen in the same transaction in which the clone is created.",params:{_honestThreshold:"Minimum number of honest keep members.",_members:"Addresses of the keep members.",_owner:"Address of the keep owner."},notice:"Initialization function."},"isActive()":{inputs:[],name:"isActive",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if the keep is active, false otherwise."},notice:"Returns true if the keep is active."},"isClosed()":{inputs:[],name:"isClosed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if the keep is closed, false otherwise."},notice:"Returns true if the keep is closed and members no longer support this keep."},"isTerminated()":{inputs:[],name:"isTerminated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if the keep has been terminated, false otherwise."},notice:"Returns true if the keep has been terminated. Keep is terminated when bonds are seized and members no longer support this keep."},"members(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"members",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"publicKey()":{inputs:[],name:"publicKey",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"submitPublicKey(bytes)":{inputs:[{internalType:"bytes",name:"_publicKey",type:"bytes"}],name:"submitPublicKey",outputs:[],stateMutability:"nonpayable",type:"function",details:"Public key is published successfully if all members submit the same value. In case of conflicts with others members submissions it will emit `ConflictingPublicKeySubmitted` event. When all submitted keys match it will store the key as keep's public key and emit a `PublicKeyPublished` event.",params:{_publicKey:"Signer's public key."},notice:"Submits a public key to the keep."}}},"contracts/bridge/ERC20Migrator.sol:ERC20Migrator":{source:"contracts/bridge/ERC20Migrator.sol",name:"ERC20Migrator",constructor:{inputs:[{internalType:"contract IERC20",name:"legacyToken",type:"address"},{internalType:"contract IERC20Mintable",name:"newToken",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"legacyToken()":{inputs:[],name:"legacyToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the legacy token that is being migrated."},"migrate(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"migrate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers part of an account's balance in the old token to this contract, and mints the same amount of new tokens for that account.",params:{amount:"amount of tokens to be migrated"}},"newToken()":{inputs:[],name:"newToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the new token to which we are migrating."}}},"contracts/bridge/ERC20Migrator.sol:IERC20Mintable":{source:"contracts/bridge/ERC20Migrator.sol",name:"IERC20Mintable",title:"ERC20Migrator",details:'This contract can be used to migrate an ERC20 token from one contract to another, where each token holder has to opt-in to the migration. To opt-in, users must approve for this contract the number of tokens they want to migrate. Once the allowance is set up, anyone can trigger the migration to the new token contract. In this way, token holders "turn in" their old balance and will be minted an equal amount in the new token. The new token contract must be mintable. ```',events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/bridge/HarmonySynapseBridge.sol:HarmonySynapseBridge":{source:"contracts/bridge/HarmonySynapseBridge.sol",name:"HarmonySynapseBridge",receive:{stateMutability:"payable",type:"receive"},events:{"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenDeposit(address,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TokenDeposit",type:"event"},"TokenDepositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"}],name:"TokenDepositAndSwap",type:"event"},"TokenMint(address,address,uint256,uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20Mintable",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenMint",type:"event"},"TokenMintAndSwap(address,address,uint256,uint256,uint8,uint8,uint256,uint256,bool,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20Mintable",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"},{indexed:!1,internalType:"bool",name:"swapSuccess",type:"bool"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenMintAndSwap",type:"event"},"TokenRedeem(address,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TokenRedeem",type:"event"},"TokenRedeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"swapMinAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"TokenRedeemAndRemove",type:"event"},"TokenRedeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"}],name:"TokenRedeemAndSwap",type:"event"},"TokenWithdraw(address,address,uint256,uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenWithdraw",type:"event"},"TokenWithdrawAndRemove(address,address,uint256,uint256,uint8,uint256,uint256,bool,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!1,internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"swapMinAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"swapDeadline",type:"uint256"},{indexed:!1,internalType:"bool",name:"swapSuccess",type:"bool"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenWithdrawAndRemove",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"GOVERNANCE_ROLE()":{inputs:[],name:"GOVERNANCE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"NODEGROUP_ROLE()":{inputs:[],name:"NODEGROUP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addKappas(bytes32[])":{inputs:[{internalType:"bytes32[]",name:"kappas",type:"bytes32[]"}],name:"addKappas",outputs:[],stateMutability:"nonpayable",type:"function"},"bridgeVersion()":{inputs:[],name:"bridgeVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"chainGasAmount()":{inputs:[],name:"chainGasAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Relays to nodes to transfers an ERC20 token cross-chain"},"depositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"depositAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Relays to nodes to both transfer an ERC20 token cross-chain, and then have the nodes execute a swap through a liquidity pool on behalf of the user."},"getFeeBalance(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getFeeBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize()":{inputs:[],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"kappaExists(bytes32)":{inputs:[{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"kappaExists",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"mint(address,address,uint256,uint256,bytes32)":{inputs:[{internalType:"address payable",name:"to",type:"address"},{internalType:"contract IERC20Mintable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"This means the SynapseBridge.sol contract must have minter access to the token attempting to be minted",params:{amount:"Amount in native token decimals to transfer cross-chain post-fees",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Nodes call this function to mint a SynERC20 (or any asset that the bridge is given minter access to). This is called by the nodes after a TokenDeposit event is emitted."},"mintAndSwap(address,address,uint256,uint256,address,uint8,uint8,uint256,uint256,bytes32)":{inputs:[{internalType:"address payable",name:"to",type:"address"},{internalType:"contract IERC20Mintable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"contract ISwap",name:"pool",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"mintAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",details:"This means the BridgeDeposit.sol contract must have minter access to the token attempting to be minted",params:{amount:"Amount in native token decimals to transfer cross-chain post-fees",deadline:"Epoch time of the deadline that the swap is allowed to be executed.",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",minDy:"Minumum amount (in final asset decimals) that must be swapped for, otherwise the user will receive the SynERC20.",pool:"Destination chain's pool to use to swap SynERC20 -> Asset. The nodes determine this by using PoolConfig.sol.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"Index of the SynERC20 asset in the pool",tokenIndexTo:"Index of the desired final asset"},notice:"Nodes call this function to mint a SynERC20 (or any asset that the bridge is given minter access to), and then attempt to swap the SynERC20 into the desired destination asset. This is called by the nodes after a TokenDepositAndSwap event is emitted."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{internalType:"uint256",name:"swapMinAmount",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",swapDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*",swapMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",swapTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:'Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:'Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setChainGasAmount(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"setChainGasAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"setWethAddress(address)":{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"}],name:"setWethAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"startBlockNumber()":{inputs:[],name:"startBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"withdraw(address,address,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to withdraw",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",to:"address on chain to send underlying assets to",token:"ERC20 compatible token to withdraw from the bridge"},notice:"Function to be called by the node group to withdraw the underlying assets from the contract"},"withdrawAndRemove(address,address,uint256,uint256,address,uint8,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"contract ISwap",name:"pool",type:"address"},{internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{internalType:"uint256",name:"swapMinAmount",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"withdrawAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to withdraw",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",pool:"Destination chain's pool to use to swap SynERC20 -> Asset. The nodes determine this by using PoolConfig.sol.",swapDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token",swapMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",swapTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on chain to send underlying assets to",token:"ERC20 compatible token to withdraw from the bridge"},notice:"Function to be called by the node group to withdraw the underlying assets from the contract"},"withdrawFees(address,address)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"withdrawFees",outputs:[],stateMutability:"nonpayable",type:"function",params:{to:"Address to send the fees to",token:"ERC20 token in which fees acccumulated to transfer"},notice:"withdraw specified ERC20 token fees to a given address"}}},"contracts/bridge/HarmonySynapseBridge.sol:IERC20Mintable":{source:"contracts/bridge/HarmonySynapseBridge.sol",name:"IERC20Mintable",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/bridge/HarmonySynapseBridge.sol:IFrax":{source:"contracts/bridge/HarmonySynapseBridge.sol",name:"IFrax",methods:{"exchangeOldForCanonical(address,uint256)":{inputs:[{internalType:"address",name:"bridge_token_address",type:"address"},{internalType:"uint256",name:"token_amount",type:"uint256"}],name:"exchangeOldForCanonical",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/MiniChefV2.sol:MiniChefV2":{source:"contracts/bridge/MiniChefV2.sol",name:"MiniChefV2",notice:"The (older) MasterChef contract gives out a constant number of SYNAPSE tokens per block. It is the only address with minting rights for SYNAPSE. The idea for this MasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token that is deposited into the MasterChef V1 (MCV1) contract. The allocation point for this pool on MCV1 is the total allocation point for all pools that receive double incentives.",constructor:{inputs:[{internalType:"contract IERC20",name:"_synapse",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Deposit(address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Deposit",type:"event"},"EmergencyWithdraw(address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"EmergencyWithdraw",type:"event"},"Harvest(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Harvest",type:"event"},"LogPoolAddition(uint256,uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocPoint",type:"uint256"},{indexed:!0,internalType:"contract IERC20",name:"lpToken",type:"address"},{indexed:!0,internalType:"contract IRewarder",name:"rewarder",type:"address"}],name:"LogPoolAddition",type:"event"},"LogSetPool(uint256,uint256,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint256",name:"allocPoint",type:"uint256"},{indexed:!0,internalType:"contract IRewarder",name:"rewarder",type:"address"},{indexed:!1,internalType:"bool",name:"overwrite",type:"bool"}],name:"LogSetPool",type:"event"},"LogSynapsePerSecond(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"synapsePerSecond",type:"uint256"}],name:"LogSynapsePerSecond",type:"event"},"LogUpdatePool(uint256,uint64,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint64",name:"lastRewardTime",type:"uint64"},{indexed:!1,internalType:"uint256",name:"lpSupply",type:"uint256"},{indexed:!1,internalType:"uint256",name:"accSynapsePerShare",type:"uint256"}],name:"LogUpdatePool",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"},"Withdraw(address,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"uint256",name:"pid",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!0,internalType:"address",name:"to",type:"address"}],name:"Withdraw",type:"event"}},stateVariables:{"totalAllocPoint()":{inputs:[],name:"totalAllocPoint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"Total allocation points. Must be the sum of all allocation points in all pools."}},methods:{"SYNAPSE()":{inputs:[],name:"SYNAPSE",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of SYNAPSE contract."},"add(uint256,address,address)":{inputs:[{internalType:"uint256",name:"allocPoint",type:"uint256"},{internalType:"contract IERC20",name:"_lpToken",type:"address"},{internalType:"contract IRewarder",name:"_rewarder",type:"address"}],name:"add",outputs:[],stateMutability:"nonpayable",type:"function",params:{_lpToken:"Address of the LP ERC-20 token.",_rewarder:"Address of the rewarder delegate.",allocPoint:"AP of the new pool."},notice:"Add a new LP to the pool. Can only be called by the owner. DO NOT add the same LP token more than once. Rewards will be messed up if you do."},"batch(bytes[],bool)":{inputs:[{internalType:"bytes[]",name:"calls",type:"bytes[]"},{internalType:"bool",name:"revertOnFail",type:"bool"}],name:"batch",outputs:[{internalType:"bool[]",name:"successes",type:"bool[]"},{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function"},"claimOwnership()":{inputs:[],name:"claimOwnership",outputs:[],stateMutability:"nonpayable",type:"function"},"deposit(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"LP token amount to deposit.",pid:"The index of the pool. See `poolInfo`.",to:"The receiver of `amount` deposit benefit."},notice:"Deposit LP tokens to MCV2 for SYNAPSE allocation."},"emergencyWithdraw(uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"emergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{pid:"The index of the pool. See `poolInfo`.",to:"Receiver of the LP tokens."},notice:"Withdraw without caring about rewards. EMERGENCY ONLY."},"harvest(uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"harvest",outputs:[],stateMutability:"nonpayable",type:"function",params:{pid:"The index of the pool. See `poolInfo`.",to:"Receiver of SYNAPSE rewards."},notice:"Harvest proceeds for transaction sender to `to`."},"lpToken(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"lpToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of the LP token for each MCV2 pool."},"massUpdatePools(uint256[])":{inputs:[{internalType:"uint256[]",name:"pids",type:"uint256[]"}],name:"massUpdatePools",outputs:[],stateMutability:"nonpayable",type:"function",params:{pids:"Pool IDs of all to be updated. Make sure to update all active pools."},notice:"Update reward variables for all pools. Be careful of gas spending!"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingOwner()":{inputs:[],name:"pendingOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingSynapse(uint256,address)":{inputs:[{internalType:"uint256",name:"_pid",type:"uint256"},{internalType:"address",name:"_user",type:"address"}],name:"pendingSynapse",outputs:[{internalType:"uint256",name:"pending",type:"uint256"}],stateMutability:"view",type:"function",params:{_pid:"The index of the pool. See `poolInfo`.",_user:"Address of user."},returns:{pending:"SYNAPSE reward for a given user."},notice:"View function to see pending SYNAPSE on frontend."},"permitToken(address,address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permitToken",outputs:[],stateMutability:"nonpayable",type:"function"},"poolInfo(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"poolInfo",outputs:[{internalType:"uint128",name:"accSynapsePerShare",type:"uint128"},{internalType:"uint64",name:"lastRewardTime",type:"uint64"},{internalType:"uint64",name:"allocPoint",type:"uint64"}],stateMutability:"view",type:"function",notice:"Info of each MCV2 pool."},"poolLength()":{inputs:[],name:"poolLength",outputs:[{internalType:"uint256",name:"pools",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns the number of MCV2 pools."},"rewarder(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"rewarder",outputs:[{internalType:"contract IRewarder",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Address of each `IRewarder` contract in MCV2."},"set(uint256,uint256,address,bool)":{inputs:[{internalType:"uint256",name:"_pid",type:"uint256"},{internalType:"uint256",name:"_allocPoint",type:"uint256"},{internalType:"contract IRewarder",name:"_rewarder",type:"address"},{internalType:"bool",name:"overwrite",type:"bool"}],name:"set",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allocPoint:"New AP of the pool.",_pid:"The index of the pool. See `poolInfo`.",_rewarder:"Address of the rewarder delegate.",overwrite:"True if _rewarder should be `set`. Otherwise `_rewarder` is ignored."},notice:"Update the given pool's SYNAPSE allocation point and `IRewarder` contract. Can only be called by the owner."},"setSynapsePerSecond(uint256)":{inputs:[{internalType:"uint256",name:"_synapsePerSecond",type:"uint256"}],name:"setSynapsePerSecond",outputs:[],stateMutability:"nonpayable",type:"function",params:{_synapsePerSecond:"The amount of Synapse to be distributed per second."},notice:"Sets the synapse per second to be distributed. Can only be called by the owner."},"synapsePerSecond()":{inputs:[],name:"synapsePerSecond",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transferOwnership(address,bool,bool)":{inputs:[{internalType:"address",name:"newOwner",type:"address"},{internalType:"bool",name:"direct",type:"bool"},{internalType:"bool",name:"renounce",type:"bool"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function"},"updatePool(uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"}],name:"updatePool",outputs:[{components:[{internalType:"uint128",name:"accSynapsePerShare",type:"uint128"},{internalType:"uint64",name:"lastRewardTime",type:"uint64"},{internalType:"uint64",name:"allocPoint",type:"uint64"}],internalType:"struct MiniChefV2.PoolInfo",name:"pool",type:"tuple"}],stateMutability:"nonpayable",type:"function",params:{pid:"The index of the pool. See `poolInfo`."},returns:{pool:"Returns the pool that was updated."},notice:"Update reward variables of the given pool."},"userInfo(uint256,address)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"}],name:"userInfo",outputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"int256",name:"rewardDebt",type:"int256"}],stateMutability:"view",type:"function",notice:"Info of each user that stakes LP tokens."},"withdraw(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"LP token amount to withdraw.",pid:"The index of the pool. See `poolInfo`.",to:"Receiver of the LP tokens."},notice:"Withdraw LP tokens from MCV2."},"withdrawAndHarvest(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"withdrawAndHarvest",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"LP token amount to withdraw.",pid:"The index of the pool. See `poolInfo`.",to:"Receiver of the LP tokens and SYNAPSE rewards."},notice:"Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`."}}},"contracts/bridge/MoonriverSynapseBridge.sol:IERC20Mintable":{source:"contracts/bridge/MoonriverSynapseBridge.sol",name:"IERC20Mintable",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/bridge/MoonriverSynapseBridge.sol:IFrax":{source:"contracts/bridge/MoonriverSynapseBridge.sol",name:"IFrax",methods:{"exchangeOldForCanonical(address,uint256)":{inputs:[{internalType:"address",name:"bridge_token_address",type:"address"},{internalType:"uint256",name:"token_amount",type:"uint256"}],name:"exchangeOldForCanonical",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/MoonriverSynapseBridge.sol:MRSynapseBridge":{source:"contracts/bridge/MoonriverSynapseBridge.sol",name:"MRSynapseBridge",receive:{stateMutability:"payable",type:"receive"},events:{"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenDeposit(address,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TokenDeposit",type:"event"},"TokenDepositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"}],name:"TokenDepositAndSwap",type:"event"},"TokenMint(address,address,uint256,uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20Mintable",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenMint",type:"event"},"TokenMintAndSwap(address,address,uint256,uint256,uint8,uint8,uint256,uint256,bool,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20Mintable",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"},{indexed:!1,internalType:"bool",name:"swapSuccess",type:"bool"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenMintAndSwap",type:"event"},"TokenRedeem(address,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TokenRedeem",type:"event"},"TokenRedeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"swapMinAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"TokenRedeemAndRemove",type:"event"},"TokenRedeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"}],name:"TokenRedeemAndSwap",type:"event"},"TokenWithdraw(address,address,uint256,uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenWithdraw",type:"event"},"TokenWithdrawAndRemove(address,address,uint256,uint256,uint8,uint256,uint256,bool,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!1,internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"swapMinAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"swapDeadline",type:"uint256"},{indexed:!1,internalType:"bool",name:"swapSuccess",type:"bool"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenWithdrawAndRemove",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"GOVERNANCE_ROLE()":{inputs:[],name:"GOVERNANCE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"NODEGROUP_ROLE()":{inputs:[],name:"NODEGROUP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addKappas(bytes32[])":{inputs:[{internalType:"bytes32[]",name:"kappas",type:"bytes32[]"}],name:"addKappas",outputs:[],stateMutability:"nonpayable",type:"function"},"bridgeVersion()":{inputs:[],name:"bridgeVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"chainGasAmount()":{inputs:[],name:"chainGasAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Relays to nodes to transfers an ERC20 token cross-chain"},"depositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"depositAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Relays to nodes to both transfer an ERC20 token cross-chain, and then have the nodes execute a swap through a liquidity pool on behalf of the user."},"getFeeBalance(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getFeeBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize()":{inputs:[],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"kappaExists(bytes32)":{inputs:[{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"kappaExists",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"mint(address,address,uint256,uint256,bytes32)":{inputs:[{internalType:"address payable",name:"to",type:"address"},{internalType:"contract IERC20Mintable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"This means the SynapseBridge.sol contract must have minter access to the token attempting to be minted",params:{amount:"Amount in native token decimals to transfer cross-chain post-fees",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Nodes call this function to mint a SynERC20 (or any asset that the bridge is given minter access to). This is called by the nodes after a TokenDeposit event is emitted."},"mintAndSwap(address,address,uint256,uint256,address,uint8,uint8,uint256,uint256,bytes32)":{inputs:[{internalType:"address payable",name:"to",type:"address"},{internalType:"contract IERC20Mintable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"contract ISwap",name:"pool",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"mintAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",details:"This means the BridgeDeposit.sol contract must have minter access to the token attempting to be minted",params:{amount:"Amount in native token decimals to transfer cross-chain post-fees",deadline:"Epoch time of the deadline that the swap is allowed to be executed.",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",minDy:"Minumum amount (in final asset decimals) that must be swapped for, otherwise the user will receive the SynERC20.",pool:"Destination chain's pool to use to swap SynERC20 -> Asset. The nodes determine this by using PoolConfig.sol.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"Index of the SynERC20 asset in the pool",tokenIndexTo:"Index of the desired final asset"},notice:"Nodes call this function to mint a SynERC20 (or any asset that the bridge is given minter access to), and then attempt to swap the SynERC20 into the desired destination asset. This is called by the nodes after a TokenDepositAndSwap event is emitted."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{internalType:"uint256",name:"swapMinAmount",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",swapDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*",swapMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",swapTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:'Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:'Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setChainGasAmount(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"setChainGasAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"setWethAddress(address)":{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"}],name:"setWethAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"startBlockNumber()":{inputs:[],name:"startBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"withdraw(address,address,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to withdraw",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",to:"address on chain to send underlying assets to",token:"ERC20 compatible token to withdraw from the bridge"},notice:"Function to be called by the node group to withdraw the underlying assets from the contract"},"withdrawAndRemove(address,address,uint256,uint256,address,uint8,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"contract ISwap",name:"pool",type:"address"},{internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{internalType:"uint256",name:"swapMinAmount",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"withdrawAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to withdraw",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",pool:"Destination chain's pool to use to swap SynERC20 -> Asset. The nodes determine this by using PoolConfig.sol.",swapDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token",swapMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",swapTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on chain to send underlying assets to",token:"ERC20 compatible token to withdraw from the bridge"},notice:"Function to be called by the node group to withdraw the underlying assets from the contract"},"withdrawFees(address,address)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"withdrawFees",outputs:[],stateMutability:"nonpayable",type:"function",params:{to:"Address to send the fees to",token:"ERC20 token in which fees acccumulated to transfer"},notice:"withdraw specified ERC20 token fees to a given address"}}},"contracts/bridge/PoolConfig.sol:PoolConfig":{source:"contracts/bridge/PoolConfig.sol",name:"PoolConfig",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"BRIDGEMANAGER_ROLE()":{inputs:[],name:"BRIDGEMANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"getPoolConfig(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"}],name:"getPoolConfig",outputs:[{components:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"poolAddress",type:"address"},{internalType:"bool",name:"metaswap",type:"bool"}],internalType:"struct PoolConfig.Pool",name:"",type:"tuple"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setPoolConfig(address,uint256,address,bool)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainID",type:"uint256"},{internalType:"address",name:"poolAddress",type:"address"},{internalType:"bool",name:"metaswap",type:"bool"}],name:"setPoolConfig",outputs:[{components:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"poolAddress",type:"address"},{internalType:"bool",name:"metaswap",type:"bool"}],internalType:"struct PoolConfig.Pool",name:"",type:"tuple"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/SynapseBridge.sol:IERC20Mintable":{source:"contracts/bridge/SynapseBridge.sol",name:"IERC20Mintable",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/bridge/SynapseBridge.sol:SynapseBridge":{source:"contracts/bridge/SynapseBridge.sol",name:"SynapseBridge",receive:{stateMutability:"payable",type:"receive"},events:{"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenDeposit(address,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TokenDeposit",type:"event"},"TokenDepositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"}],name:"TokenDepositAndSwap",type:"event"},"TokenMint(address,address,uint256,uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20Mintable",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenMint",type:"event"},"TokenMintAndSwap(address,address,uint256,uint256,uint8,uint8,uint256,uint256,bool,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20Mintable",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"},{indexed:!1,internalType:"bool",name:"swapSuccess",type:"bool"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenMintAndSwap",type:"event"},"TokenRedeem(address,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"TokenRedeem",type:"event"},"TokenRedeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"swapMinAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"TokenRedeemAndRemove",type:"event"},"TokenRedeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{indexed:!1,internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{indexed:!1,internalType:"uint256",name:"minDy",type:"uint256"},{indexed:!1,internalType:"uint256",name:"deadline",type:"uint256"}],name:"TokenRedeemAndSwap",type:"event"},"TokenWithdraw(address,address,uint256,uint256,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenWithdraw",type:"event"},"TokenWithdrawAndRemove(address,address,uint256,uint256,uint8,uint256,uint256,bool,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"contract IERC20",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"},{indexed:!1,internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{indexed:!1,internalType:"uint256",name:"swapMinAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"swapDeadline",type:"uint256"},{indexed:!1,internalType:"bool",name:"swapSuccess",type:"bool"},{indexed:!0,internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"TokenWithdrawAndRemove",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"GOVERNANCE_ROLE()":{inputs:[],name:"GOVERNANCE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"NODEGROUP_ROLE()":{inputs:[],name:"NODEGROUP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"addKappas(bytes32[])":{inputs:[{internalType:"bytes32[]",name:"kappas",type:"bytes32[]"}],name:"addKappas",outputs:[],stateMutability:"nonpayable",type:"function"},"bridgeVersion()":{inputs:[],name:"bridgeVersion",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"chainGasAmount()":{inputs:[],name:"chainGasAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Relays to nodes to transfers an ERC20 token cross-chain"},"depositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"depositAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Relays to nodes to both transfer an ERC20 token cross-chain, and then have the nodes execute a swap through a liquidity pool on behalf of the user."},"getFeeBalance(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getFeeBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize()":{inputs:[],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"kappaExists(bytes32)":{inputs:[{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"kappaExists",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"mint(address,address,uint256,uint256,bytes32)":{inputs:[{internalType:"address payable",name:"to",type:"address"},{internalType:"contract IERC20Mintable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"This means the SynapseBridge.sol contract must have minter access to the token attempting to be minted",params:{amount:"Amount in native token decimals to transfer cross-chain post-fees",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Nodes call this function to mint a SynERC20 (or any asset that the bridge is given minter access to). This is called by the nodes after a TokenDeposit event is emitted."},"mintAndSwap(address,address,uint256,uint256,address,uint8,uint8,uint256,uint256,bytes32)":{inputs:[{internalType:"address payable",name:"to",type:"address"},{internalType:"contract IERC20Mintable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"contract ISwap",name:"pool",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"mintAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",details:"This means the BridgeDeposit.sol contract must have minter access to the token attempting to be minted",params:{amount:"Amount in native token decimals to transfer cross-chain post-fees",deadline:"Epoch time of the deadline that the swap is allowed to be executed.",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",minDy:"Minumum amount (in final asset decimals) that must be swapped for, otherwise the user will receive the SynERC20.",pool:"Destination chain's pool to use to swap SynERC20 -> Asset. The nodes determine this by using PoolConfig.sol.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"Index of the SynERC20 asset in the pool",tokenIndexTo:"Index of the desired final asset"},notice:"Nodes call this function to mint a SynERC20 (or any asset that the bridge is given minter access to), and then attempt to swap the SynERC20 into the desired destination asset. This is called by the nodes after a TokenDepositAndSwap event is emitted."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{internalType:"uint256",name:"swapMinAmount",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",swapDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*",swapMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",swapTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:'Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract ERC20Burnable",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:'Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setChainGasAmount(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"setChainGasAmount",outputs:[],stateMutability:"nonpayable",type:"function"},"setWethAddress(address)":{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"}],name:"setWethAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"startBlockNumber()":{inputs:[],name:"startBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function"},"withdraw(address,address,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to withdraw",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",to:"address on chain to send underlying assets to",token:"ERC20 compatible token to withdraw from the bridge"},notice:"Function to be called by the node group to withdraw the underlying assets from the contract"},"withdrawAndRemove(address,address,uint256,uint256,address,uint8,uint256,uint256,bytes32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"contract ISwap",name:"pool",type:"address"},{internalType:"uint8",name:"swapTokenIndex",type:"uint8"},{internalType:"uint256",name:"swapMinAmount",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"},{internalType:"bytes32",name:"kappa",type:"bytes32"}],name:"withdrawAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to withdraw",fee:"Amount in native token decimals to save to the contract as fees",kappa:"kappa*",pool:"Destination chain's pool to use to swap SynERC20 -> Asset. The nodes determine this by using PoolConfig.sol.",swapDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token",swapMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",swapTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on chain to send underlying assets to",token:"ERC20 compatible token to withdraw from the bridge"},notice:"Function to be called by the node group to withdraw the underlying assets from the contract"},"withdrawFees(address,address)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"address",name:"to",type:"address"}],name:"withdrawFees",outputs:[],stateMutability:"nonpayable",type:"function",params:{to:"Address to send the fees to",token:"ERC20 token in which fees acccumulated to transfer"},notice:"withdraw specified ERC20 token fees to a given address"}}},"contracts/bridge/SynapseERC20.sol:SynapseERC20":{source:"contracts/bridge/SynapseERC20.sol",name:"SynapseERC20",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-DOMAIN_SEPARATOR}."},"MINTER_ROLE()":{inputs:[],name:"MINTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from the caller. See {ERC20-_burn}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,uint8,address)":{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"uint8",name:"decimals",type:"uint8"},{internalType:"address",name:"owner",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{decimals:"Token name",name:"Token name",owner:"admin address to be initialized with",symbol:"Token symbol"},notice:"Initializes this ERC20 contract with the given parameters."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-nonces}."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC20Permit-permit}."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/bridge/SynapseERC20Factory.sol:SynapseERC20Factory":{source:"contracts/bridge/SynapseERC20Factory.sol",name:"SynapseERC20Factory",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"SynapseERC20Created(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"contractAddress",type:"address"}],name:"SynapseERC20Created",type:"event"}},methods:{"deploy(address,string,string,uint8,address)":{inputs:[{internalType:"address",name:"synapseERC20Address",type:"address"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"uint8",name:"decimals",type:"uint8"},{internalType:"address",name:"owner",type:"address"}],name:"deploy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",params:{decimals:"Token name",name:"Token name",owner:"admin address to be initialized with",symbol:"Token symbol",synapseERC20Address:"address of the synapseERC20Address contract to initialize with"},returns:{_0:"Address of the newest node management contract created*"},notice:"Deploys a new node"}}},"contracts/bridge/interfaces/IECDSANodeManagement.sol:IECDSANodeManagement":{source:"contracts/bridge/interfaces/IECDSANodeManagement.sol",name:"IECDSANodeManagement",title:"IECDSANodeManagement interface",details:"implement this interface to develop a a factory-patterned ECDSA node management contract*",notice:"Interface for the ECDSA node management interface.",methods:{"initialize(address,address[],uint256)":{inputs:[{internalType:"address",name:"_owner",type:"address"},{internalType:"address[]",name:"_members",type:"address[]"},{internalType:"uint256",name:"_honestThreshold",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/IERC20Migrator.sol:IERC20Migrator":{source:"contracts/bridge/interfaces/IERC20Migrator.sol",name:"IERC20Migrator",methods:{"migrate(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"migrate",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/IMasterChef.sol:IMasterChef":{source:"contracts/bridge/interfaces/IMasterChef.sol",name:"IMasterChef",methods:{"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_pid",type:"uint256"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"poolInfo(uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"}],name:"poolInfo",outputs:[{components:[{internalType:"contract IERC20",name:"lpToken",type:"address"},{internalType:"uint256",name:"allocPoint",type:"uint256"},{internalType:"uint256",name:"lastRewardBlock",type:"uint256"},{internalType:"uint256",name:"accSynapsePerShare",type:"uint256"}],internalType:"struct IMasterChef.PoolInfo",name:"",type:"tuple"}],stateMutability:"view",type:"function"},"totalAllocPoint()":{inputs:[],name:"totalAllocPoint",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/bridge/interfaces/IMetaSwapDeposit.sol:IMetaSwapDeposit":{source:"contracts/bridge/interfaces/IMetaSwapDeposit.sol",name:"IMetaSwapDeposit",title:"IMetaSwapDeposit interface",details:"implement this interface to develop a a factory-patterned ECDSA node management contract*",notice:"Interface for the meta swap contract.",methods:{"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getToken(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/IMiniChefV2.sol:IMiniChefV2":{source:"contracts/bridge/interfaces/IMiniChefV2.sol",name:"IMiniChefV2",methods:{"deposit(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"emergencyWithdraw(uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"emergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"harvest(uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"harvest",outputs:[],stateMutability:"nonpayable",type:"function"},"poolLength()":{inputs:[],name:"poolLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updatePool(uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"}],name:"updatePool",outputs:[{components:[{internalType:"uint128",name:"accSynapsePerShare",type:"uint128"},{internalType:"uint64",name:"lastRewardTime",type:"uint64"},{internalType:"uint64",name:"allocPoint",type:"uint64"}],internalType:"struct IMiniChefV2.PoolInfo",name:"",type:"tuple"}],stateMutability:"nonpayable",type:"function"},"userInfo(uint256,address)":{inputs:[{internalType:"uint256",name:"_pid",type:"uint256"},{internalType:"address",name:"_user",type:"address"}],name:"userInfo",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"withdrawAndHarvest(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"}],name:"withdrawAndHarvest",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/IRewarder.sol:IRewarder":{source:"contracts/bridge/interfaces/IRewarder.sol",name:"IRewarder",methods:{"onSynapseReward(uint256,address,address,uint256,uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"synapseAmount",type:"uint256"},{internalType:"uint256",name:"newLpAmount",type:"uint256"}],name:"onSynapseReward",outputs:[],stateMutability:"nonpayable",type:"function"},"pendingTokens(uint256,address,uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"synapseAmount",type:"uint256"}],name:"pendingTokens",outputs:[{internalType:"contract IERC20[]",name:"",type:"address[]"},{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"}}},"contracts/bridge/interfaces/ISwap.sol:ISwap":{source:"contracts/bridge/interfaces/ISwap.sol",name:"ISwap",methods:{"addLiquidity(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"addLiquidity",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"calculateRemoveLiquidity(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"calculateRemoveLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function"},"calculateSwap(uint8,uint8,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getA()":{inputs:[],name:"getA",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getToken(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"getTokenBalance(uint8)":{inputs:[{internalType:"uint8",name:"index",type:"uint8"}],name:"getTokenBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getTokenIndex(address)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"}],name:"getTokenIndex",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"getVirtualPrice()":{inputs:[],name:"getVirtualPrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"initialize(address[],uint8[],string,string,uint256,uint256,uint256,address)":{inputs:[{internalType:"contract IERC20[]",name:"pooledTokens",type:"address[]"},{internalType:"uint8[]",name:"decimals",type:"uint8[]"},{internalType:"string",name:"lpTokenName",type:"string"},{internalType:"string",name:"lpTokenSymbol",type:"string"},{internalType:"uint256",name:"a",type:"uint256"},{internalType:"uint256",name:"fee",type:"uint256"},{internalType:"uint256",name:"adminFee",type:"uint256"},{internalType:"address",name:"lpTokenTargetAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"removeLiquidity(uint256,uint256[],uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256[]",name:"minAmounts",type:"uint256[]"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidity",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityImbalance(uint256[],uint256,uint256)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"maxBurnAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityImbalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"removeLiquidityOneToken(uint256,uint8,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"},{internalType:"uint256",name:"minAmount",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"removeLiquidityOneToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"swap(uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/ISynapseBridge.sol:ISynapseBridge":{source:"contracts/bridge/interfaces/ISynapseBridge.sol",name:"ISynapseBridge",methods:{"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function"},"depositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"depositAndSwap",outputs:[],stateMutability:"nonpayable",type:"function"},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function"},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/ISynapseERC20.sol:ISynapseERC20":{source:"contracts/bridge/interfaces/ISynapseERC20.sol",name:"ISynapseERC20",methods:{"initialize(string,string,uint8,address)":{inputs:[{internalType:"string",name:"_name",type:"string"},{internalType:"string",name:"_symbol",type:"string"},{internalType:"uint8",name:"_decimals",type:"uint8"},{internalType:"address",name:"owner",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/interfaces/IWETH9.sol:IWETH9":{source:"contracts/bridge/interfaces/IWETH9.sol",name:"IWETH9",receive:{stateMutability:"payable",type:"receive"},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"guy",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"src",type:"address"},{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"wad",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/libraries/SignedSafeMath.sol:SignedSafeMath":{source:"contracts/bridge/libraries/SignedSafeMath.sol",name:"SignedSafeMath"},"contracts/bridge/mocks/ERC20Mock.sol:ERC20Mock":{source:"contracts/bridge/mocks/ERC20Mock.sol",name:"ERC20Mock",constructor:{inputs:[{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"uint256",name:"supply",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/bridge/mocks/RewarderBrockenMock.sol:RewarderBrokenMock":{source:"contracts/bridge/mocks/RewarderBrockenMock.sol",name:"RewarderBrokenMock",methods:{"onSynapseReward(uint256,address,address,uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"onSynapseReward",outputs:[],stateMutability:"nonpayable",type:"function"},"pendingTokens(uint256,address,uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"synapseAmount",type:"uint256"}],name:"pendingTokens",outputs:[{internalType:"contract IERC20[]",name:"rewardTokens",type:"address[]"},{internalType:"uint256[]",name:"rewardAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"}}},"contracts/bridge/mocks/RewarderMock.sol:RewarderMock":{source:"contracts/bridge/mocks/RewarderMock.sol",name:"RewarderMock",constructor:{inputs:[{internalType:"uint256",name:"_rewardMultiplier",type:"uint256"},{internalType:"contract IERC20",name:"_rewardToken",type:"address"},{internalType:"address",name:"_MASTERCHEF_V2",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"onSynapseReward(uint256,address,address,uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"address",name:"user",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"synapseAmount",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"onSynapseReward",outputs:[],stateMutability:"nonpayable",type:"function"},"pendingTokens(uint256,address,uint256)":{inputs:[{internalType:"uint256",name:"pid",type:"uint256"},{internalType:"address",name:"user",type:"address"},{internalType:"uint256",name:"synapseAmount",type:"uint256"}],name:"pendingTokens",outputs:[{internalType:"contract IERC20[]",name:"rewardTokens",type:"address[]"},{internalType:"uint256[]",name:"rewardAmounts",type:"uint256[]"}],stateMutability:"view",type:"function"}}},"contracts/bridge/testing/NodeEnv.sol:NodeEnv":{source:"contracts/bridge/testing/NodeEnv.sol",name:"NodeEnv",title:"NodeEnv contract",author:"Synapse Authors",notice:"This contract implements a key-value store for storing variables on which synapse nodes must coordinate methods are purposely arbitrary to allow these fields to be defined in synapse improvement proposals.This token is used for configuring different tokens on the bridge and mapping them across chains.*",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"ConfigUpdate(string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"key",type:"string"}],name:"ConfigUpdate",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"BRIDGEMANAGER_ROLE()":{inputs:[],name:"BRIDGEMANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"get(string)":{inputs:[{internalType:"string",name:"_key",type:"string"}],name:"get",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"gets the value associated with the key"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"keyCount()":{inputs:[],name:"keyCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"this is useful for enumerating through all keys in the env",notice:"get the length of the config"},"keyValueByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"keyValueByIndex",outputs:[{internalType:"string",name:"",type:"string"},{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",notice:"gets the key/value pair by it's index Requirements: - `index` must be strictly less than {length}."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"set(string,string)":{inputs:[{internalType:"string",name:"_key",type:"string"},{internalType:"string",name:"_value",type:"string"}],name:"set",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"caller must have bridge manager role",notice:"sets the key"}}},"contracts/bridge/testing/SynapseToken.sol:Synapse":{source:"contracts/bridge/testing/SynapseToken.sol",name:"Synapse",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-DOMAIN_SEPARATOR}."},"MINTER_ROLE()":{inputs:[],name:"MINTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from the caller. See {ERC20-_burn}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Destroys `amount` tokens from `account`, deducting from the caller's allowance. See {ERC20-_burn} and {ERC20-allowance}. Requirements: - the caller must have allowance for ``accounts``'s tokens of at least `amount`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-nonces}."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC20Permit-permit}."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/bridge/utils/AddressArrayUtils.sol:AddressArrayUtils":{source:"contracts/bridge/utils/AddressArrayUtils.sol",name:"AddressArrayUtils"},"contracts/bridge/utils/EnumerableStringMap.sol:EnumerableStringMap":{source:"contracts/bridge/utils/EnumerableStringMap.sol",name:"EnumerableStringMap",title:"EnumerableStringMap",details:"Library for managing an enumerable variant of Solidity's https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`] type. Maps have the following properties: - Entries are added, removed, and checked for existence in constant time (O(1)). - Entries are enumerated in O(n). No guarantees are made on the ordering. this isn't a terribly gas efficient implementation because it emphasizes usability over gas efficiency by allowing arbitrary length string memorys. If Gettetrs/Setters are going to be used frequently in contracts consider using the OpenZeppeling Bytes32 implementation this also differs from the OpenZeppelin implementation by keccac256 hashing the string memorys so we can use enumerable bytes32 set"},"contracts/bridge/utils/TimelockController.sol:TimelockController":{source:"contracts/bridge/utils/TimelockController.sol",name:"TimelockController",details:"Contract module which acts as a timelocked controller. When set as the owner of an `Ownable` smart contract, it enforces a timelock on all `onlyOwner` maintenance operations. This gives time for users of the controlled contract to exit before a potentially dangerous maintenance operation is applied. By default, this contract is self administered, meaning administration tasks have to go through the timelock process. The proposer (resp executor) role is in charge of proposing (resp executing) operations. A common use case is to position this {TimelockController} as the owner of a smart contract, with a multisig or a DAO as the sole proposer. _Available since v3.3._",constructor:{inputs:[{internalType:"uint256",name:"minDelay",type:"uint256"},{internalType:"address[]",name:"proposers",type:"address[]"},{internalType:"address[]",name:"executors",type:"address[]"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"CallExecuted(bytes32,uint256,address,uint256,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"id",type:"bytes32"},{indexed:!0,internalType:"uint256",name:"index",type:"uint256"},{indexed:!1,internalType:"address",name:"target",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"}],name:"CallExecuted",type:"event",details:"Emitted when a call is performed as part of operation `id`."},"CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"id",type:"bytes32"},{indexed:!0,internalType:"uint256",name:"index",type:"uint256"},{indexed:!1,internalType:"address",name:"target",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"},{indexed:!1,internalType:"bytes",name:"data",type:"bytes"},{indexed:!1,internalType:"bytes32",name:"predecessor",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"delay",type:"uint256"}],name:"CallScheduled",type:"event",details:"Emitted when a call is scheduled as part of operation `id`."},"Cancelled(bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"id",type:"bytes32"}],name:"Cancelled",type:"event",details:"Emitted when operation `id` is cancelled."},"MinDelayChange(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldDuration",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newDuration",type:"uint256"}],name:"MinDelayChange",type:"event",details:"Emitted when the minimum delay for future operations is modified."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"EXECUTOR_ROLE()":{inputs:[],name:"EXECUTOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PROPOSER_ROLE()":{inputs:[],name:"PROPOSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"TIMELOCK_ADMIN_ROLE()":{inputs:[],name:"TIMELOCK_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"cancel(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"cancel",outputs:[],stateMutability:"nonpayable",type:"function",details:"Cancel an operation. Requirements: - the caller must have the 'proposer' role."},"execute(address,uint256,bytes,bytes32,bytes32)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"bytes32",name:"predecessor",type:"bytes32"},{internalType:"bytes32",name:"salt",type:"bytes32"}],name:"execute",outputs:[],stateMutability:"payable",type:"function",details:"Execute an (ready) operation containing a single transaction. Emits a {CallExecuted} event. Requirements: - the caller must have the 'executor' role."},"executeBatch(address[],uint256[],bytes[],bytes32,bytes32)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"},{internalType:"bytes32",name:"predecessor",type:"bytes32"},{internalType:"bytes32",name:"salt",type:"bytes32"}],name:"executeBatch",outputs:[],stateMutability:"payable",type:"function",details:"Execute an (ready) operation containing a batch of transactions. Emits one {CallExecuted} event per transaction in the batch. Requirements: - the caller must have the 'executor' role."},"getMinDelay()":{inputs:[],name:"getMinDelay",outputs:[{internalType:"uint256",name:"duration",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the minimum delay for an operation to become valid. This value can be changed by executing an operation that calls `updateDelay`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getTimestamp(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"getTimestamp",outputs:[{internalType:"uint256",name:"timestamp",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the timestamp at with an operation becomes ready (0 for unset operations, 1 for done operations)."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"hashOperation(address,uint256,bytes,bytes32,bytes32)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"bytes32",name:"predecessor",type:"bytes32"},{internalType:"bytes32",name:"salt",type:"bytes32"}],name:"hashOperation",outputs:[{internalType:"bytes32",name:"hash",type:"bytes32"}],stateMutability:"pure",type:"function",details:"Returns the identifier of an operation containing a single transaction."},"hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"},{internalType:"bytes32",name:"predecessor",type:"bytes32"},{internalType:"bytes32",name:"salt",type:"bytes32"}],name:"hashOperationBatch",outputs:[{internalType:"bytes32",name:"hash",type:"bytes32"}],stateMutability:"pure",type:"function",details:"Returns the identifier of an operation containing a batch of transactions."},"isOperation(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"isOperation",outputs:[{internalType:"bool",name:"pending",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether an id correspond to a registered operation. This includes both Pending, Ready and Done operations."},"isOperationDone(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"isOperationDone",outputs:[{internalType:"bool",name:"done",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether an operation is done or not."},"isOperationPending(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"isOperationPending",outputs:[{internalType:"bool",name:"pending",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether an operation is pending or not."},"isOperationReady(bytes32)":{inputs:[{internalType:"bytes32",name:"id",type:"bytes32"}],name:"isOperationReady",outputs:[{internalType:"bool",name:"ready",type:"bool"}],stateMutability:"view",type:"function",details:"Returns whether an operation is ready or not."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"schedule(address,uint256,bytes,bytes32,bytes32,uint256)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"},{internalType:"bytes32",name:"predecessor",type:"bytes32"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256",name:"delay",type:"uint256"}],name:"schedule",outputs:[],stateMutability:"nonpayable",type:"function",details:"Schedule an operation containing a single transaction. Emits a {CallScheduled} event. Requirements: - the caller must have the 'proposer' role."},"scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"datas",type:"bytes[]"},{internalType:"bytes32",name:"predecessor",type:"bytes32"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256",name:"delay",type:"uint256"}],name:"scheduleBatch",outputs:[],stateMutability:"nonpayable",type:"function",details:"Schedule an operation containing a batch of transactions. Emits one {CallScheduled} event per transaction in the batch. Requirements: - the caller must have the 'proposer' role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"updateDelay(uint256)":{inputs:[{internalType:"uint256",name:"newDelay",type:"uint256"}],name:"updateDelay",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the minimum timelock duration for future operations. Emits a {MinDelayChange} event. Requirements: - the caller must be the timelock itself. This can only be achieved by scheduling and later executing an operation where the timelock is the target and the data is the ABI-encoded call to this function."}}},"contracts/bridge/wrappers/GMXWrapper.sol:GMXWrapper":{source:"contracts/bridge/wrappers/GMXWrapper.sol",name:"GMXWrapper",methods:{"bridge()":{inputs:[],name:"bridge",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"_addr",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"gmx()":{inputs:[],name:"gmx",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"_addr",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"_recipient",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/wrappers/GMXWrapper.sol:IGMX":{source:"contracts/bridge/wrappers/GMXWrapper.sol",name:"IGMX",methods:{"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"burn(address,uint256)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"_account",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/wrappers/HarmonyBridgeZap.sol:HarmonyBridgeZap":{source:"contracts/bridge/wrappers/HarmonyBridgeZap.sol",name:"HarmonyBridgeZap",constructor:{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"},{internalType:"address",name:"_swapOne",type:"address"},{internalType:"address",name:"tokenOne",type:"address"},{internalType:"address",name:"_swapTwo",type:"address"},{internalType:"address",name:"tokenTwo",type:"address"},{internalType:"contract ISynapseBridge",name:"_synapseBridge",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateSwap(address,uint8,uint8,uint256)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"wraps SynapseBridge redeem()"},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"wraps SynapseBridge redeem()"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token",chainId:"which underlying chain to bridge assets onto",liqDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*",liqMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",liqTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:'Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:'Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"swapAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapAndRedeem",outputs:[],stateMutability:"nonpayable",type:"function"},"swapAndRedeemAndRemove(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"swapAndRedeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function"},"swapAndRedeemAndSwap(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"swapTokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"swapTokenIndexTo",type:"uint8"},{internalType:"uint256",name:"swapMinDy",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"swapAndRedeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function"},"swapETHAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapETHAndRedeem",outputs:[],stateMutability:"payable",type:"function"},"swapMap(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"swapMap",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"swapTokensMap(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"swapTokensMap",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/bridge/wrappers/HarmonyBridgeZap.sol:IFrax":{source:"contracts/bridge/wrappers/HarmonyBridgeZap.sol",name:"IFrax",methods:{"exchangeCanonicalForOld(address,uint256)":{inputs:[{internalType:"address",name:"bridge_token_address",type:"address"},{internalType:"uint256",name:"token_amount",type:"uint256"}],name:"exchangeCanonicalForOld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/wrappers/L1BridgeZap.sol:L1BridgeZap":{source:"contracts/bridge/wrappers/L1BridgeZap.sol",name:"L1BridgeZap",title:"L1BridgeZap",details:"This contract should be deployed with a base Swap.sol address and a SynapseBridge.sol address, otherwise, it will not function.",notice:"This contract is responsible for handling user Zaps into the SynapseBridge contract, through the Synapse Swap contracts. It does so It does so by combining the action of addLiquidity() to the base swap pool, and then calling either deposit() or depositAndSwap() on the bridge. This is done in hopes of automating portions of the bridge user experience to users, while keeping the SynapseBridge contract logic small.",constructor:{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"},{internalType:"contract ISwap",name:"_baseSwap",type:"address"},{internalType:"contract ISynapseBridge",name:"_synapseBridge",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"baseTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"baseTokens",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateRemoveLiquidityOneToken(uint256,uint8)":{inputs:[{internalType:"uint256",name:"tokenAmount",type:"uint256"},{internalType:"uint8",name:"tokenIndex",type:"uint8"}],name:"calculateRemoveLiquidityOneToken",outputs:[{internalType:"uint256",name:"availableTokenAmount",type:"uint256"}],stateMutability:"view",type:"function",params:{tokenAmount:"the amount of LP token to burn",tokenIndex:"index of which token will be withdrawn"},returns:{availableTokenAmount:"calculated amount of underlying token available to withdraw"},notice:"Calculate the amount of underlying token available to withdraw when withdrawing via only single token"},"calculateTokenAmount(uint256[],bool)":{inputs:[{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bool",name:"deposit",type:"bool"}],name:"calculateTokenAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This shouldn't be used outside frontends for user estimates.",params:{amounts:"an array of token amounts to deposit or withdrawal, corresponding to pooledTokens. The amount should be in each pooled token's native precision.",deposit:"whether this is a deposit or a withdrawal"},returns:{_0:"token amount the user will receive"},notice:'A simple method to calculate prices from deposits or withdrawals, excluding fees but including slippage. This is helpful as an input into the various "min" parameters on calls to fight front-running'},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Wraps SynapseBridge deposit() function"},"depositAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"depositAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Wraps SynapseBridge depositAndSwap() function"},"depositETH(address,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"depositETH",outputs:[],stateMutability:"payable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to"},notice:"Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions"},"depositETHAndSwap(address,uint256,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"depositETHAndSwap",outputs:[],stateMutability:"payable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to bridge assets to",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Wraps SynapseBridge depositAndSwap() function to make it compatible w/ ETH -> WETH conversions"},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to redeem into the bridge"},notice:"Wraps SynapseBridge redeem() function"},"zapAndDeposit(address,uint256,address,uint256[],uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256[]",name:"liquidityAmounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"zapAndDeposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{chainId:"which chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",liquidityAmounts:"the amounts of each token to add, in their native precision",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"Combines adding liquidity to the given Swap, and calls deposit() on the bridge using that LP token"},"zapAndDepositAndSwap(address,uint256,address,uint256[],uint256,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256[]",name:"liquidityAmounts",type:"uint256[]"},{internalType:"uint256",name:"minToMint",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"zapAndDepositAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{chainId:"which chain to bridge assets onto",liqDeadline:"latest timestamp to accept this transaction",liquidityAmounts:"the amounts of each token to add, in their native precision",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",minToMint:"the minimum LP tokens adding this amount of liquidity should mint, otherwise revert. Handy for front-running mitigation",swapDeadline:"latest timestamp to accept this transaction*",to:"address on other chain to bridge assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:"Combines adding liquidity to the given Swap, and calls depositAndSwap() on the bridge using that LP token"}}},"contracts/bridge/wrappers/L2BridgeZap.sol:L2BridgeZap":{source:"contracts/bridge/wrappers/L2BridgeZap.sol",name:"L2BridgeZap",constructor:{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"},{internalType:"address",name:"_swapOne",type:"address"},{internalType:"address",name:"tokenOne",type:"address"},{internalType:"address",name:"_swapTwo",type:"address"},{internalType:"address",name:"tokenTwo",type:"address"},{internalType:"contract ISynapseBridge",name:"_synapseBridge",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateSwap(address,uint8,uint8,uint256)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"wraps SynapseBridge redeem()"},"depositETH(address,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"depositETH",outputs:[],stateMutability:"payable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to"},notice:"Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions"},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"wraps SynapseBridge redeem()"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token",chainId:"which underlying chain to bridge assets onto",liqDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*",liqMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",liqTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:'Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:'Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"swapAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapAndRedeem",outputs:[],stateMutability:"nonpayable",type:"function"},"swapAndRedeemAndRemove(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"swapAndRedeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function"},"swapAndRedeemAndSwap(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"swapTokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"swapTokenIndexTo",type:"uint8"},{internalType:"uint256",name:"swapMinDy",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"swapAndRedeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function"},"swapETHAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapETHAndRedeem",outputs:[],stateMutability:"payable",type:"function"},"swapETHAndRedeemAndSwap(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"swapTokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"swapTokenIndexTo",type:"uint8"},{internalType:"uint256",name:"swapMinDy",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"swapETHAndRedeemAndSwap",outputs:[],stateMutability:"payable",type:"function"},"swapMap(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"swapMap",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"swapTokensMap(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"swapTokensMap",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/bridge/wrappers/MigratorBridgeZap.sol:MigratorBridgeZap":{source:"contracts/bridge/wrappers/MigratorBridgeZap.sol",name:"MigratorBridgeZap",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},methods:{"migrate(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"migrate",outputs:[],stateMutability:"nonpayable",type:"function"},"migrateAndBridge(uint256,address,uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"}],name:"migrateAndBridge",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/wrappers/MoonriverBridgeZap.sol:IFrax":{source:"contracts/bridge/wrappers/MoonriverBridgeZap.sol",name:"IFrax",methods:{"exchangeCanonicalForOld(address,uint256)":{inputs:[{internalType:"address",name:"bridge_token_address",type:"address"},{internalType:"uint256",name:"token_amount",type:"uint256"}],name:"exchangeCanonicalForOld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/bridge/wrappers/MoonriverBridgeZap.sol:MoonriverBridgeZap":{source:"contracts/bridge/wrappers/MoonriverBridgeZap.sol",name:"MoonriverBridgeZap",constructor:{inputs:[{internalType:"address payable",name:"_wethAddress",type:"address"},{internalType:"address",name:"_swapOne",type:"address"},{internalType:"address",name:"tokenOne",type:"address"},{internalType:"address",name:"_swapTwo",type:"address"},{internalType:"address",name:"tokenTwo",type:"address"},{internalType:"contract ISynapseBridge",name:"_synapseBridge",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH_ADDRESS()":{inputs:[],name:"WETH_ADDRESS",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"calculateSwap(address,uint8,uint8,uint256)":{inputs:[{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"}],name:"calculateSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{dx:"the amount of tokens the user wants to sell. If the token charges a fee on transfers, use the amount that gets transferred after the fee.",tokenIndexFrom:"the token the user wants to sell",tokenIndexTo:"the token the user wants to buy"},returns:{_0:"amount of tokens the user will receive"},notice:"Calculate amount of tokens you receive on swap"},"deposit(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"wraps SynapseBridge redeem()"},"depositETH(address,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"depositETH",outputs:[],stateMutability:"payable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which chain to bridge assets onto",to:"address on other chain to bridge assets to"},notice:"Wraps SynapseBridge deposit() function to make it compatible w/ ETH -> WETH conversions"},"redeem(address,uint256,address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"redeem",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees*",chainId:"which underlying chain to bridge assets onto",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:"wraps SynapseBridge redeem()"},"redeemAndRemove(address,uint256,address,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"redeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount of (typically) LP token to pass to the nodes to attempt to removeLiquidity() with to redeem for the underlying assets of the LP token",chainId:"which underlying chain to bridge assets onto",liqDeadline:"Specificies the deadline that the nodes are allowed to try to redeem/swap the LP token*",liqMinAmount:"Specifies the minimum amount of the underlying asset needed for the nodes to execute the redeem/swap",liqTokenIndex:"Specifies which of the underlying LP assets the nodes should attempt to redeem for",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge"},notice:'Wraps redeemAndRemove on SynapseBridge Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"redeemAndSwap(address,uint256,address,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"redeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"Amount in native token decimals to transfer cross-chain pre-fees",chainId:"which underlying chain to bridge assets onto",deadline:"latest timestamp to accept this transaction*",minDy:"the min amount the user would like to receive, or revert to only minting the SynERC20 token crosschain.",to:"address on other chain to redeem underlying assets to",token:"ERC20 compatible token to deposit into the bridge",tokenIndexFrom:"the token the user wants to swap from",tokenIndexTo:"the token the user wants to swap to"},notice:'Wraps redeemAndSwap on SynapseBridge.sol Relays to nodes that (typically) a wrapped synAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain. This function indicates to the nodes that they should attempt to redeem the LP token for the underlying assets (E.g "swap" out of the LP token)'},"swapAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapAndRedeem",outputs:[],stateMutability:"nonpayable",type:"function"},"swapAndRedeemAndRemove(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"liqTokenIndex",type:"uint8"},{internalType:"uint256",name:"liqMinAmount",type:"uint256"},{internalType:"uint256",name:"liqDeadline",type:"uint256"}],name:"swapAndRedeemAndRemove",outputs:[],stateMutability:"nonpayable",type:"function"},"swapAndRedeemAndSwap(address,uint256,address,uint8,uint8,uint256,uint256,uint256,uint8,uint8,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"swapTokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"swapTokenIndexTo",type:"uint8"},{internalType:"uint256",name:"swapMinDy",type:"uint256"},{internalType:"uint256",name:"swapDeadline",type:"uint256"}],name:"swapAndRedeemAndSwap",outputs:[],stateMutability:"nonpayable",type:"function"},"swapETHAndRedeem(address,uint256,address,uint8,uint8,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"},{internalType:"uint8",name:"tokenIndexFrom",type:"uint8"},{internalType:"uint8",name:"tokenIndexTo",type:"uint8"},{internalType:"uint256",name:"dx",type:"uint256"},{internalType:"uint256",name:"minDy",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],name:"swapETHAndRedeem",outputs:[],stateMutability:"payable",type:"function"},"swapMap(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"swapMap",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"swapTokensMap(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"swapTokensMap",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"}}}};new Tr({el:"#app",router:new rp({routes:[{path:"/",component:Dp,props:()=>({json:Pp})},{path:"*",component:Cp,props:e=>({json:Pp[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(lp)})},387:(e,t,n)=>{var a=n(268);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("0b345cf4",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],o=s[0],r={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[o]?a[o].parts.push(r):n.push(a[o]={id:o,parts:[r]})}return n}n.d(t,{Z:()=>c});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},o=i&&(document.head||document.getElementsByTagName("head")[0]),r=null,u=0,p=!1,d=function(){},l=null,y="data-vue-ssr-id",m="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function c(e,t,n,i){p=n,l=i||{};var o=a(e,t);return h(o),function(t){for(var n=[],i=0;i<o.length;i++){var r=o[i];(u=s[r.id]).refs--,n.push(u)}for(t?h(o=a(e,t)):o=[],i=0;i<n.length;i++){var u;if(0===(u=n[i]).refs){for(var p=0;p<u.parts.length;p++)u.parts[p]();delete s[u.id]}}}}function h(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(b(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var o=[];for(i=0;i<n.parts.length;i++)o.push(b(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:o}}}}function f(){var e=document.createElement("style");return e.type="text/css",o.appendChild(e),e}function b(e){var t,n,a=document.querySelector("style["+y+'~="'+e.id+'"]');if(a){if(p)return d;a.parentNode.removeChild(a)}if(m){var i=u++;a=r||(r=f()),t=w.bind(null,a,i,!1),n=w.bind(null,a,i,!0)}else a=f(),t=g.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var T,v=(T=[],function(e,t){return T[e]=t,T.filter(Boolean).join("\n")});function w(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var s=document.createTextNode(i),o=e.childNodes;o[t]&&e.removeChild(o[t]),o.length?e.insertBefore(s,o[t]):e.appendChild(s)}}function g(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(y,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(267)})();